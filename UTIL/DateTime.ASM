;DATETIME.COM -- CP/M-65 Date&Time UTILITY
;BY D. LAUSBERG	 (C)2021
;V1.0	30.06.21
;V1.1	02.07.21	max speed

VERSION	= $11

;SYSTEM CONSTANTS
DMA	=  $FE
DPH	=  $F8
FCB1	=  $F6
FCB2	=  $F4
BDOS	=  $F0
INBUF	=  $EC
CCPV	=  $DE
TPA	=  $0200
BUFBEG	=  $8000

YSPBDIV	= 1
YBPD	= 2
YSYS	= 7

CMDVEC	= $00
CMDKEY	= $01
PNT	= $02
CNT	= $03
MCNT	= $04
RCOUNT	= $05
BUFFER	= $08
NUMBER	= $09
HEXL	= $0A
HEXH	= $0B
HEXX	= $0C
DIVL	= $0D
DIVM	= $0E
DIVH	= $0F
DRIVE	= $10
ERRNO	= $11
YBUF	= $12

DT	= $20		;raw Date&Time info
SEC	= DT
MIN	= DT+1
HOUR	= DT+2
DAY	= DT+3
DD	= DT+4
MM	= DT+5
YY	= DT+6

;I2C commands

C_I2CCLR	= $00
C_I2CStop	= $01
C_I2CADEV	= $02
C_I2CR8		= $03
C_I2CR16	= $04
C_I2CRDEV	= $05
C_I2CWByte	= $06
C_I2CRByte	= $07
C_I2CRLB	= $08

;BDOS COMMANDS

BOOT	= $00
CONIN	= $01
CONOUT	= $02
STROUT	= $09
GETLIN	= $0A
DSKSEL	= $0E
DEFDRV	= $19
BIOS	= $1A

;BIOS COMMANDS

SETTRK	= 10
SETSEC	= 11
READ	= 12
WRITE	= 13
SET_TIMER1 = $11
GET_TIMER1 = $12

;CONTROL CODES

EOT	= $00
BS	= $08
LF	= $0A
CLS	= $0C
CR	= $0D
SPACE	= $20
SEMI	= $3B

;6532 ADDRESSES

PAD	= $F680
PADD	= $F681
PBD	= $F682
PBDD	= $F683

;I2C adresses
RTC	= $68
24C32	= $57

;ERROR CODES

NOCOM	= $80
MISPAR	= $81
ILLPAR	= $82
TOOMCH	= $83
EOL	= $84
I2CError = $85
NO_RTC	= $86

	ORG TPA

DUTIL	JSR INIT 		;INIT VARIABLES

DUTILL	JSR STATUS
	LDA #PROMPT
	LDY #PROMPT/256
	JSR PRTSTR
	LDX #GETLIN
	JSR BDOS
	LDY #0			;SET COMMAND POINTER
	STY CMDVEC
DUTIL1	JSR DECODE		;DECODE AND EXEC COMMAND
	BCC DUTIL1
	CMP #EOL 		;END OF COMMAND
	BEQ DUTILL
	JSR ERROR
	JMP DUTILL


INIT	LDA #0			;RESET VARIABLES
	LDX #$30
INIT2	STA 0,X
	DEX
	BPL INIT2
	LDA PAD
	ORA #%00000001	;PA0 = 1
	STA PAD
	LDA PADD	
	ORA #%00000001	; PA0 is Output
	STA PADD
	LDY #C_I2CCLR		;clear I2C
	JSR I2C
	RTS


STATUS	LDA #STATM		;DISPLAY STATUS
	LDY #STATM/256
	JSR PRTSTR
	RTS


PRTDEC	JSR COMNUM		;PRINTS DECIMAL
	PHA
	TYA
	JSR COMNUM
	PHA
	TYA
	JSR PRTNUM
	PLA
	JSR PRTNUM
	PLA
	JSR PRTNUM
	RTS


COMNUM	LDY #0			;DIV/10
COMNU1	SEC
	SBC #10
	BCC COMNU2
	INY
	BNE COMNU1

COMNU2	ADC #10
	RTS


PRTNUM	ORA #$30 		;PRINT A NUMBER
	JMP PRTCHR


DECODE	JSR GNCHR		;GET NEXT CHR
	BCS DECODX
	CMP #SEMI		;IS IT A SEPARATOR
	BNE DECOD1
	JSR GNCHR
	BCS DECODX
DECOD1	LDY #0			;SEARCH COMMAND
	STA CMDKEY
DECOD4	LDA CMDTAB,Y
	BEQ DECOD2		;COMMAND NOT FOUND
	CMP CMDKEY
	BEQ DECOD3		;FOUND
	INY
	INY
	INY
	BNE DECOD4

DECOD3	INY
	LDA CMDTAB,Y
	PHA
	INY
	LDA CMDTAB,Y
	PHA
	RTS			;EXEC

DECOD2	LDA #NOCOM		;UNKNOWN COMMAND
	SEC
DECODX	RTS

CMDTAB	DB 'Z'
	DD TIME-1
	DB 'K'
	DD DATE-1
	DB 'X'
	DD EXIT-1
	DB '?'
	DD HELP-1
	DB 'Z'
	DD WAIT-1
	DB '/'
	DD REPEAT-1

	DB $00

;==========  COMMANDS  ============= 


TIME	JSR GET_DT		;get date&time info
	BCS TIMEX		;display Time
	LDA #TIME_M
	LDY #TIME_M/256
	JSR PRTSTR
	LDA HOUR
	AND #$3F		;clear 12/24h & AM/PM bits
	JSR PRTHEX
	LDA #':
	JSR PRTCHR
	LDA MIN
	JSR PRTHEX
	LDA #':
	JSR PRTCHR
	LDA SEC
	JSR PRTHEX
	JSR CRLF	
	CLC
TIMEX	RTS


DATE	JSR GET_DT		;get date&time info
	BCS DATEX		;display date
	LDA #DATE_M
	LDY #DATE_M/256
	JSR PRTSTR
	LDA DAY
	JSR Weekday
	LDA DD
	JSR PRTHEX
	LDA #'.
	JSR PRTCHR
	LDA MM
	AND #$7F		;clear century bit
	JSR PRTHEX
	LDA #'.
	JSR PRTCHR
	LDA #$20
	JSR PRTHEX
	LDA YY
	JSR PRTHEX
	JSR CRLF
	CLC
DATEX	RTS


EXIT	LDX #BOOT
	JSR BDOS


HELP	LDA #HELPM
	LDY #HELPM/256
	JSR PRTSTR
	RTS


WAIT	JSR GDEC 		;WAIT NN/10 S
	BCS WAITX
	STA CNT
WAIT3	LDA #10
	STA MCNT 		;100 MS
WAIT2	LDX #78
WAIT1	DEY
	BNE WAIT1
	DEX
	BNE WAIT1
	DEC MCNT
	BNE WAIT2
	DEC CNT
	BNE WAIT3
	CLC
WAITX	RTS


REPEAT	LDA RCOUNT		;REPEAT COMMAND
	BEQ REPEA1
REPEA3	DEC RCOUNT		;ONE MORE TIME
	BEQ REPEA5
	LDA #0
	STA CMDVEC
	CLC
	RTS

REPEA1	JSR GDEC 		;GET NO. OF REPEATS
	BCS REPEA2
	STA RCOUNT
	CMP #0
	BNE REPEA3
	LDA #ILLPAR
REPEA4	SEC
	RTS

REPEA2	CMP #MISPAR
	BNE REPEA4
	LDA #10			;DEFAULT 10 TIMES
	STA RCOUNT
	BNE REPEA3

REPEA5	LDA #EOL
	SEC
	RTS


;======  SUBROUTINES  ============== 

GET_DT	LDA #RTC		;get date&time info from DS3231
	LDY #C_I2CADEV		;wait for device ready and adress it
	JSR I2C
	BCS GETDTX
	LDA #0			;start with reg $00
	LDY #C_I2CR8
	JSR I2C
	BCS GETDTY
	LDA #RTC
	LDY #C_I2CRDEV		;now read
	JSR I2C
	BCS GETDTY
	LDY #0
GETDT1	STY YBUF
	LDY #C_I2CRByte
	JSR I2C
	BCS GETDTY
	LDY YBUF
	STA DT,Y		;save DT byte
	INY
	CPY #6
	BCC GETDT1		;7 bytes to read
	LDY #C_I2CRLB		;read last byte
	JSR I2C
	STA DT+6
	CLC
GETDTX	RTS

GETDTY	LDA #I2CError
	RTS

WeekDay	AND #$07
	LDY #$FF	;Y is CHR pointer
	TAX		;X is Day Pointer 1..7
	DEX
	BEQ WeekD1
WeekD2	INY
	LDA DAYTAB,Y
	BNE WeekD2
	DEX
	BNE WeekD2

WeekD1	INY
	LDA DAYTAB,Y
	BEQ WeekD3
	JSR PRTCHR
	JMP WeekD1

WeekD3	LDA #DAYM
	LDY #DAYM/256
	JSR PRTSTR
	RTS


DISHEX	JSR PRTHEX		;DISPLAYS A HEX
	LDA #SPACE
	JSR PRTCHR
	RTS


DISASC	AND #$7F
	CMP #$20
	BCC DISAS1
	CMP #$7F
	BCC DISAS2
DISAS1	LDA #'.
DISAS2	JSR PRTCHR
	RTS


GDEC	JSR GETHEX		;GETS A DECIMAL FROM LINE
	BCS GDECX
	AND #$0F
	CMP #10
	BCS GDEC1
	STA NUMBER		;EINER
	LDA HEXL
	AND #$F0
	LSR A			;ZEHNER*8
	PHA
	CLC
	ADC NUMBER
	STA NUMBER
	PLA
	LSR A
	LSR A			;ZEHNER*2
	CLC
	ADC NUMBER
	CPY #3			;Y= HEXH
	BCS GDEC1
GDEC5	DEY
	BMI GDEC4
	ADC #100
	BCC GDEC5
GDEC1	LDA #ILLPAR
	SEC
GDECX	RTS

GDEC4	STA NUMBER
	CLC
	RTS


GETHEX	LDA #0			;GET HEX NUMBER FROM LINE
	STA HEXL 		;RESET HEX
	STA HEXH
	TAX
GETHE2	JSR GETNIB		;GET NIBBLE TO HEX
	BCS GETHE1
	INX
	CPX #5
	BCC GETHE2
GETHE5	LDA #ILLPAR		;ILLEGAL PARAMETER
	SEC
	RTS

GETHE1	CPX #0
	BNE GETHE3
	CMP #SPACE
	BEQ GETHE2
	CMP #EOL
	BEQ GETHE6
	CMP #SEMI
	BNE GETHE5
GETHE6	LDA #MISPAR
	SEC
	RTS

GETHE3	CMP #SEMI
	BEQ GETHE4
	CMP #',
	BEQ GETHE4
	CMP #EOL
	BNE GETHE5
GETHE4	LDA HEXL
	LDY HEXH
	CLC
	RTS


GETNIB	JSR GNCHR		;GET NIBBLE TO HEX
	BCS GETNIX
	CMP #'0
	BCC GETNI1
	CMP #$3A
	BCC GETNI2
	CMP #'A
	BCC GETNI1
	CMP #'G
	BCC GETNI3
GETNI1	SEC
GETNIX	RTS

GETNI3	CLC
	ADC #9
GETNI2	AND #$0F
	LDY #4
GETNI4	ASL HEXL
	ROL HEXH
	ROL HEXX
	DEY
	BNE GETNI4
	ORA HEXL
	STA HEXL
	CLC
	RTS


GNCHR	LDY #0
	INC CMDVEC
	LDA CMDVEC
	CMP (INBUF),Y
	BCS GNCHRX
	TAY
	LDA (INBUF),Y
	JSR UPCASE
	CLC
	RTS

GNCHRX	LDA #EOL
	RTS


UPCASE	CMP #'a			;LOWER --> UPPER CASE
	BCC UPCASX
	CMP #'~
	BCS UPCASX
	AND #$5F
UPCASX	RTS

;--------------I2C ---------------

I2C	PHA		;Y I2C Command, A Argument
	TYA
	ASL A		; *2
	TAY
	LDA JMPTAB,Y
	STA I2C_F+1
	INY
	LDA JMPTAB,Y
	STA I2C_F+2
	PLA
I2C_F	JMP JMPTAB	;JMPTAB ist Dummy for function calls

JMPTAB	DW I2CCLR, I2CStop, I2CADEV, I2CR8
	DW I2CR16, I2CRDEV, I2CWByte, I2CRByte, I2CRLB

;--------- I2C Commands ------------------------------

I2CCLR	JSR I2CStop	;clear I2C-Bus
	JSR I2CStart
	JSR DUP
	LDX #9		;dummy read 9 bits
CLR1	JSR CLK
	DEX
	BNE CLR1
	JSR I2CStart
	JMP I2CStop


I2CADEV	ASL A		;send 7 bit dev adr to write
	JSR I2CWAIT	;set for write
	BCS ADEVX
	TAY
	JSR I2CSTART
	TYA
	JSR I2CWByte
	BCS ADEVY
ADEVX	RTS

ADEVY	LDA #I2CError
	RTS


I2CR16	TAY		;send word in ZP,A to slave
	LDX $00,Y
	INY
	LDA $00,Y
	PHA
	TXA
	JSR I2CWByte
	PLA
	BCS R16X
	JSR I2CWByte
R16X	RTS


I2CRDEV			;send 7 bit dev adr to read
	SEC
	ROL A		;set for read
	TAY
	JSR I2CSTART
	TYA
	JSR I2CWByte
	RTS

I2CR8			;sent reg byte
I2CWByte		;write byte in A to slave
	TAY		;Y to save A
	JSR DDN
	JSR CLKDN
	LDX #8		;send 8 bit
WByte2	JSR DUP
	TYA
	ASL A		;bit in C
	TAY
	BCS WByte1
	JSR DDN		;if C=0
WBYTE1	JSR CLK
	DEX
	BNE WByte2
	JMP IS_ACK

I2CRBYTE		;read byte from slave
	JSR I2CRB	;read 1 byte
	JSR I2CACK
	TYA
	CLC		;Byte in A
	RTS

I2CRLB			;read last byte from slave
	JSR I2CRB	;read 1 byte
	JSR I2CNAK	;send NAK to terminate
	JSR I2CSTOP	
	TYA
	CLC		;Byte in A
	RTS



; I2C subroutines

I2CRB	LDY #0		; Y=0 to save byte
	JSR DUP
	LDX #8		;read 8 Bit
RByte1	JSR CLKUP	;SCL = 1
	LDA PBD		;read 1 bit in C
	ASL A
	ASL A		;now bit 6 is in C
	TYA
	ROL A
	TAY
	DEC PAD		;SCL = 0
	DEX
	BNE RBYTE1
	RTS		;byte in Y

I2CWAIT	PHA		;wait for dev, dev nr in A
	LDA #3		;max. 600 ms wait
	LDY #SET_TIMER1
	JSR JBIOS
	JSR I2CStart
I2CWT2	PLA
	PHA
	JSR I2CWByte
	BCC I2CWT1
	LDY #GET_TIMER1
	JSR JBIOS
	CMP #0
	BNE I2CWT2
	
I2C_BRK	PLA
	LDA #NO_RTC
	SEC
	RTS

I2CWT1	PLA
	CLC
	RTS



; basic I2C states

I2CStart		;I2C start condition
	JSR DUP
	JSR CLKUP
	JSR DDN
	JSR CLKDN
	RTS

I2CStop			; I2C stop condition
	JSR DDN
	JSR CLKUP
	JSR DUP
	CLC
	RTS

I2CACK	JSR DDN		; Master sends ACK
	JSR CLK
	JSR DUP		; release SDA
	RTS

I2CNAK	JSR DUP		; Master sends NAK
	JSR CLK
	RTS

IS_ACK	JSR DUP		;Check for ACK from slave
	JSR CLKUP
	JSR DIN		;ACK bit in C
	JSR CLKDN
	RTS		; C=0 is ACK


; Bit I/O for I2C  PB6 = SDA, PA0 = SCL

DUP	LDA PBDD	;SDA = 1
	AND #%10111111	;PB6 is Input
	STA PBDD
	RTS

DDN	LDA PBD		;SDA = 0
	AND #%10111111	; PB6 = 0
	STA PBD
	LDA PBDD
	ORA #%01000000	; PB6 is Output
	STA PBDD
	RTS

DIN	LDA PBD		; read 1 bit in C
	ASL A
	ASL A		; now bit 6 is in C
	RTS

CLK	LDA PAD		; SCL = 1
	ORA #%00000001	; PA0 is Output
	STA PAD
	DEC PAD		; SCL = 0
	RTS

CLKUP	LDA PAD		; SCL = 1
	ORA #%00000001	; PA0 is Output
	STA PAD
	RTS

CLKDN	LDA PAD		; SCL = 0
	AND #%11111110
	STA PAD
	RTS

;---------------------------------

JBIOS	LDX #BIOS
	JMP BDOS


ERROR	STA ERRNO		;ERROR ROUTINE
	JSR CRLF
	LDA #ERRTAB		;SET CCPV
	STA CCPV
	LDA #ERRTAB/256
	STA CCPV+1
	LDY #0			;CHECK ERROR CODE
	LDA (CCPV),Y
ERROR1	BEQ ERROR4		;END OF ERROR ROUTINE
	CMP ERRNO
	BEQ ERROR3
ERROR2	JSR INCCPV		;SKIP ERROR MESSAGE
	BNE ERROR2
	JSR INCCPV
	JMP ERROR1

ERROR3	JSR INCCPV
	PHA
	JSR ERRTYP		;PRINT ERROR TYPE
	JSR INCCPV
	LDA CCPV 		;PRINT ERROR MESSAGE
	LDY CCPV+1
	JSR PRTSTR
	PLA
	BPL ERROR5
	JSR ASKRTY		;ASK FOR RETRY
	LDA ERRNO
	RTS

ERROR4	JSR UETYP		;UNKNOWN ERROR
ERROR5	SEC
	RTS


ERRTYP	LDY #0			;PRINT ERROR TYPE
ERRTY1	LSR A			;SHIFT SOURCE BIT IN C
	BCS ERRTY2
	INY			;X= X+5
	INY
	INY
	INY
	INY
	BNE ERRTY1

ERRTY2	LDA ETYPTB,Y
	BEQ UETYP		;LAST CHR?
	JSR PRTCHR
	INY
	BNE ERRTY2

UETYP	LDA #ERRM1
	LDY #ERRM1/256
	JSR PRTSTR
	LDA ERRNO
	JSR PRTHEX

CRLF	LDA #CRLFM		;PRINTS A NEWLINE
	LDY #CRLFM/256

PRTSTR	LDX #STROUT
	JMP BDOS


PRTCHR	LDX #CONOUT		;PRINTS A CHR
	JMP BDOS


INCCPV	INC CCPV 		;INC CCPV
	BNE INCCP1
	INC CCPV+1
INCCP1	LDA (CCPV),Y
	RTS


ASKRTY	LDA #RTYMES		;RETRY?
	LDY #RTYMES/256
	JSR PRTSTR
	LDX #CONIN
	JSR BDOS
	JSR UPCASE
	CMP #'Y
	BNE ASKRT1
	CLC
	RTS

ASKRT1	SEC
	RTS


PRTHEX	PHA			;PRINTS A HEX NUMBER
	LSR A
	LSR A
	LSR A
	LSR A
	JSR PRTNIB		;PRINT NIBBLE
	PLA
	AND #$0F

PRTNIB	CMP #$0A
	BCC PRTNI1
	ADC #6
PRTNI1	ADC #$30
	JSR PRTCHR
	RTS


ERRM1	DB ' Error $',EOT
RTYMES	DB CR,LF,'Retry	(Y/N) ? ',EOT

ETYPTB	DB 'BIOS',$00,'BDOS',$00,'CCP',$00,$00
	DB 'RSX',$00,$00,'USER',$00

ERRTAB	DB $F9,$01,'Invalid Drive',EOT
	DB $DE,$82,'Directory full',EOT
	DB $DD,$82,'File not found',EOT
	DB $DC,$02,'File exists',EOT
	DB $D9,$02,'Invalid FCB',EOT
	DB $D8,$82,'Disk full',EOT
	DB $D6,$82,'File is R/O',EOT
	DB $86,$10,'RTC not responding', EOT
	DB $85,$10,'I2C Bus Error',EOT
	DB $84,$10,'End of Line',EOT
	DB $83,$10,'Too Much Parameters',EOT
	DB $82,$10,'Illegal Parameter',EOT
	DB $81,$10,'Missing Parameter',EOT
	DB $80,$10,'Unknown Command',EOT

	DB $00

DAYTAB	DB 'Montag',EOT,'Dienstag',EOT,'Mittwoch',EOT,'Donnerstag',EOT
	DB 'Freitag',EOT,'Samstag',EOT,'Sonntag',EOT
DAYM	DB ', den ',EOT


STATM	DB CR,LF,'DateTime	V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30, EOT

PROMPT	DB CR,LF,'Command >',EOT

CRLFM	DB CR,LF,EOT

TIME_M	DB CR, LF,' Uhrzeit: ',EOT

DATE_M	DB CR, LF,'   Datum: ', EOT

HELPM	DB CLS,'	DateTime V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30
	DB '			(c) 30.6.2021',CR,LF
	DB 'Command Summary:',CR,LF
	DB ' K	display Kalenderdatum	        '
	DB ' Z	display Zeit',CR,LF
	DB ' /nn	repeat nn times',CR,LF
	DB ' ?	prints this screen	'
	DB ' ',SEMI,'	command separator',CR,LF
	DB ' X	exit to CP/M		',CR,LF
	DB EOT


	END
