;EDIT.COM -- CP/M-65 DEBUGGER
;BY D. LAUSBERG	 (C)2022
;V1.0	06.12.22
;V1.1	28.06.23	correct error message when deleting chr at pos 0
;V1.2	09.07.25	VT compatible version & error corrections
VERSION	= $12

;SYSTEM CONSTANTS

DMA	= $FE
FCB1	= $F6
BDOS	= $F0
INBUF	= $EC
CCPV	= $E0
TPA	= $0200

;Page 0 cells

LINE	= $00		;line to edit
LIN1	= $02		;= LINE+1
SA	= $04		;source adr for move
TA	= $06		;target adr for move
PNT	= $08		;adr pnt
TXTEND	= $0A		;end of text
HIMEM	= $0C
CURPOS	= $0E		;cursor position
XPOS	= $0F		;buffer curpos

MODE	= $10		;mode flag Bit 7 OW=0  / INS=1
			;	   BIT 6 TXT=0 / FORTH=1

CFLAG	= $11		;mode flag Bit 7 last chr needs to be erased
			;	   BIT 6 last printable chr needs erased

LINNR	= $13		;line nr
CMDKEY	= $15		;command key

ABUF	= $16		;temp buffer
XBUF	= $17
ERRNO	= $18
ERRCNT	= $19		;error counter for RDFILE
CNT	= $1A		;counter

;BDOS COMMANDS

BOOT	= $00
CONIN	= $01
CONOUT	= $02
CONIO	= $06
STROUT	= $09
GETLIN	= $0A
DSKSEL	= $0E
OPEN	= $0F
CLOSE	= $10
RDSEQ	= $14
WRITE	= $15
CREATE	= $16
DEFDRV	= $19
BIOS	= $1A

;CONTROL CODES
CTRLA	= $01		;PG down
CTRLB	= $02		;nop
CTRLC	= $03		;nop
CTRLD	= $04		;->
CTRLE	= $05		;cursor up
CTRLF	= $06		;TAB
CTRLG	= $07		;delete chr
BS	= $08		;<-
TAB	= $09		;->
LF	= $0A		;cursor down
VT_KEY	= $0B		;cursor up
CTRLL	= $0C		;LOAD file
CR	= $0D
CTRLN	= $0E		;insert new page
CTRLO	= $0F		;nop
CTRLP	= $10		;nop
CTRLQ	= $11		;QUIT
CTRLR	= $12		;Pg up
CTRLS	= $13		;<-
CTRLT	= $14		;nop
CTRLU	= $15		;update screen
CTRLV	= $16		;toggle insert / ow
CTRLW	= $17		;WRITE file
CTRLX	= $18		;LF
CTRLY	= $19		;delete line
CTRLZ	= $1A		;clear page
ESC	= $1B		;HELP & Status Screen
CTRLCROSS = $1C		;toggle FORTH / Text
CTRLPLUS = $1D		;nop
DEL	= $7F		;delete chr & cursor <-

SP	= $20

EOT	= $00
EOT1	= $1A		;alt EOT
FS	= $1C		;HOME command - not used in VT version
GS	= $1D		;GS command - not used in VT version

;PARAMETERS

LLEN	= 64-1		;max 64 chr per line
LPS	= 16-1		;lines per screen

;ERROR CODES
NOTFND	= $DD
DOUBLE	= $DC
EOF	= $D7
NOCOM	= $80
MEMOVL	= $81
LIN2LONG = $82		;line from input file too long
ILLPAR	= $83
MISPAR	= $84
EOL	= $85		;end of line (internal only)


	ORG TPA

EDIT	LDA #$0C	;print $0C to activate VT function in TERATERM
	JSR CTLOUT
	LDA #PROMPT
	LDY #PROMPT/256
	JSR PRTSTR
	JSR WAITKEY
	JSR INIT	;INIT VARIABLES
	BCS EDITE

EDITL	JSR SETLN1	;set LIN1=LINE+1
	JSR GETCHR	;edit loop
	BCS EDITC
	CMP #DEL	;RUBOUT?
	BNE EDIT8
	JSR RUBOUT
	JMP EDITL

EDIT8	PHA
	JSR PRTCHR
	PLA
	LDY #LLEN
	CPY CURPOS
	BEQ EDIT3
	BIT MODE
	BPL EDIT3
	PHA		;insert
	LDY #LLEN
	JSR CHK_LC	;check if last chr is printable&penult is SP
EDIT5	DEY		;make room for 1 chr
	LDA (LINE),Y
	STA (LIN1),Y
	CPY CURPOS
	BNE EDIT5
	PLA
	STA (LINE),Y	;save chr
	INC CURPOS
	JSR P2EOL	;print to end of txt
	JMP EDITL

EDIT3	LDY CURPOS	;OW
	STA (LINE),Y
	CPY #LLEN
	BCS EDIT7
	INY
	STY CURPOS
	BNE EDITL

EDIT7	LDA #BS
	JSR CTLOUT
	JMP EDITL

EDITC	JSR DECODE
	BCC EDITL

EDITE	JSR ERROR
	JSR WAITKEY
	JSR UPDSCR	;clear screen
	JMP EDITL




DECODE	ASL A		;decode & exec COMMAND
	TAY
	LDA CMDTAB,Y
	PHA
	INY
	LDA CMDTAB,Y
	PHA
	RTS		;EXEC

DECOD2	LDA #NOCOM	;UNKNOWN COMMAND
	SEC
DECODX	RTS

;========== COMMANDS ============= 
DEBUG	NOP		;debug call for test
	NOP
	NOP
	CLC
	RTS


RUBOUT	LDY CURPOS	;delete chr left from cursor
	BNE RUBOUT1
	CLC		;if CURPOS=0 do nothing
	RTS

RUBOUT1	JSR CURL


DELCHAR	LDY CURPOS	;delete chr
	CPY #LLEN
	BCS DELCHR1
DELCHR2	LDA (LIN1),Y
	STA (LINE),Y
	INY
	CPY #LLEN
	BCC DELCHR2
	LDA #SP
	STA (LINE),Y
	LDA CFLAG
	ORA #%01000000	;del last printable chr
	STA CFLAG
	JSR P2EOL
	CLC
	RTS


DELCHR1	LDA #SP		;del last chr in line
	STA (LINE),Y
	JSR PRTCHR	;print space
	JMP CURR2	;and cursor back



CURL	LDY CURPOS	;cursor left
	BEQ CURL1
	DEY
	STY CURPOS
	LDA #BS
	JSR CTLOUT
CURL1	CLC
	RTS


CURR	LDY CURPOS	;cursor right
	LDA (LINE),Y
	JSR PRTCHR
	CPY #LLEN
	BCC CURR1
CURR2	LDA #BS
	JSR CTLOUT
	CLC
	RTS

CURR1	INC CURPOS
	RTS


CURUP	JSR DECLINE	;cursor up
	BCS CURUP1
	JSR F1LIN	;check for page limit
	SEC
	LDA LIN1
	SBC LINE
	LDA LIN1+1
	SBC LINE+1
	BCS CURUP2	;if yes -> update screen
	JSR LIN12LINE
CURUP3	JMP UPDSCR

CURUP2	JSR LIN12LINE
	JSR OUTVT
CURUP1	CLC
	RTS


CURDN	JSR INCLINE	;cursor down
	BCS CURDN1
	JSR LIN12L
	JSR Q1LIN	;1. line of next screen reached?
	BCC CURUP3	;then show next screen
	JSR OUTLF
CURDN1	CLC
	RTS


PAGEUP	JSR F1LIN	;1 page up
	JMP CURUP


PAGEDN	JSR F1LIN	;1 page down
	CLC
	LDA #LLEN+1*16/256
	ADC LINE+1
	STA LIN1+1
	LDY LINE
	STY LIN1
	JSR CHKTXE	;check for out of bounds
	BCS PAGEDN1
	JSR LIN12L
	JMP UPDSCR

PAGEDN1	CLC		;do nothing
	RTS


RETURN	JSR CURZERO	;set cursor to col 0
	BIT MODE	;do CR
	BMI RET1	;if OW mode
	JSR INCLINE	;inc LINE result in LIN1
	BCC RET2	;if new line
	JSR ILINE	;insert it
	BCS RETX
	JSR LIN12LINE
	JSR CLRLINE
	JSR SETLC
RET2	JSR LIN12LINE
	JSR OUTLF	;LF
	JSR P2EOL	;print complete line
	CLC
RETX	RTS

RET1	JSR ILINE	;INS mode
	BCS RETX
	JSR LINE2LIN1
	JSR CLRLINE
	JSR SETLC
PRT2EOS	LDA LINE	;print to end of screen
	PHA
	LDA LINE+1
	PHA
	LDA #0		;set line cnt = 0
	STA CNT
RET4	JSR SETLC	;print rest of page
	JSR P2EOL	;print complete line
	JSR INCLINE
	JSR LIN12L
	JSR Q1LIN	;1. line of next page reached?
	BCC RET3
	JSR OUTLF
	INC CNT
	BNE RET4

RET3	JSR OUTVT	;move cursor to inserted line
	DEC CNT
	BNE RET3
	PLA
	STA LINE+1
	PLA
	STA LINE
	RTS


DELLINE	JSR INCLINE	;delete line
	BCC DELLIN1	;last line?
	JSR DELLIN2	;yes -> clear line
	LDA #LLEN+1	;DEC TXTEND by LLIN+1
	LDY #0
	JSR DECTEND
	JMP CURUP	;CURUP

DELLIN1	LDA LINE+1	;LINE=TXTEND?
	LDY LINE
	JSR CHKBUF	;1. line?
	BCS DELLIN2
	LDA LINE	;move A/Y bytes to LINE until TXTEND
	STA TA
	LDA LINE+1
	STA TA+1
	LDA TXTEND
	STA SA
	LDA TXTEND+1
	STA SA+1
	LDA #LLEN+1
	LDY #0
	JSR MOVDN
	LDA #LLEN+1	;DEC TXTEND by LLIN+1
	LDY #0
	JSR DECTEND
	JMP PRT2EOS	;print rest of screen

DELLIN2	JSR LINE2LIN1	
	JSR CLRLINE
	JSR SETLC
	JSR CLEARL
	JSR CURZERO
	CLC
	RTS


PWORD	JSR CURR	;Jump 1 word right
	LDY CURPOS
	CPY #LLEN	;EOL reached
	BEQ PWORD2
	LDA (LINE),Y
	CMP #SP		;skip BLs
	BEQ PWORD
PWORD1	JSR CURR
	LDY CURPOS
	CPY #LLEN	;EOL reached
	BEQ PWORD2
	LDA (LINE),Y
	CMP #SP
	BNE PWORD1
PWORD2	CLC
	RTS


UPDSCR	JSR F1LIN	;update screen
	LDA LINE	;save LINE
	PHA
	LDA LINE+1
	PHA
	JSR CLEARSCR
	LDA #0
	STA ABUF	;line counter
UPDSCR1	JSR SETLC
	JSR P2EOL
	JSR INCLINE
	BCS UPDSCR2
	INC ABUF
	LDA ABUF
	CMP #LPS+1
	BCS UPDSCR2
	JSR LIN12LINE
	JSR OUTLF
	JMP UPDSCR1

UPDSCR2	JSR FSOUT	;cursor to 1,1
	PLA
	STA LINE+1	;restore LINE
	PLA
	STA LINE
	CLC
	RTS


RDFILE	JSR GETFN	;READ FILE
	BCS RDFIL1
	JSR SETFCB
	BCS RDFIL6
RDFIL2	LDX #OPEN
	JSR BDOS
	BCS RDFILX
	JSR RESVEC	;reset file vectors
RDFIL3	JSR FREAD	;file read
	BCS RDFILX
	JSR SETLIN0	;set LINE = BUFFER
	JSR UPDSCR
RDFILX	RTS

RDFIL1	CMP #MISPAR
	BNE RDFIL6
	LDY #1		;if there is a filename
	LDA (FCB1),Y
	CMP #SP
	BNE RDFIL2	;take it
	LDA #MISPAR
RDFIL6	SEC
	RTS


WFILE	JSR GETFN	;Write file
	BCS WFIL1
	JSR SETFCB
	BCS WFILX
WFIL2	LDX #CREATE
	JSR BDOS
	BCS WFIL4
WFIL3	JSR FWRITE	;write file
	BCS WFILX
	JSR UPDSCR
WFILX	RTS

WFIL1	CMP #MISPAR
	BNE WFIL5
	LDY #1
	LDA (FCB1),Y
	CMP #SP
	BNE WFIL2
	LDA #MISPAR
WFIL5	SEC
	RTS

WFIL4	CMP #DOUBLE
	BNE WFIL5
	LDX #OPEN
	JSR BDOS
	BCC WFIL3
	RTS



QUIT	JSR CLEARSCR
	LDX #BOOT
	JMP BDOS


TOGINS	LDA MODE
	EOR #%10000000	;toggle ins/ow flag
	STA MODE
	CLC
	RTS


TOGTXT	LDA MODE
	EOR #%01000000	;toggle TXT/FORTH flag
	STA MODE
	CLC
	RTS


HELP	JSR CLEARSCR
	LDA #HELPM
	LDY #HELPM/256
	JSR PRTSTR
	BIT MODE	;INS / OW?
	BPL HELP1
	LDA #INSERTM
	LDY #INSERTM/256
	JSR PRTSTR
	JMP HELP2

HELP1	LDA #OWM
	LDY #OWM/256
	JSR PRTSTR
HELP2	BIT MODE	;FORTH / TXT?
	BVS HELP3
	LDA #TEXTM
	LDY #TEXTM/256
	JSR PRTSTR
	JMP HELP4

HELP3	LDA #FORTHM
	LDY #FORTHM/256
	JSR PRTSTR
HELP4	JSR PACTFH
	JSR CRLF
	LDA #PROMPT
	LDY #PROMPT/256
	JSR PRTSTR
	JSR WAITKEY
	JSR CLEARSCR
	JSR UPDSCR
	RTS

Noop	CLC		;no operation
	RTS


;======  SUBROUTINES  ============== 

INIT	JSR RESVEC	;init variables
	LDY BDOS+2	;HEAP=BDOS-$FF
	DEY
	STY HIMEM+1
	LDA BDOS+1
	STA HIMEM
	JSR DELLINE	;delete 1. line
	LDY #1
	LDA #SP		;check for filename
	CMP (FCB1),Y
	BEQ INITX
	JSR RDFIL2	;and load it
	BCC INIT1
	CMP #NOTFND
	BNE INIT3
	LDX #CREATE
	JSR BDOS
	BCC INIT2
INIT3	SEC
INIT1	RTS

INIT2	LDA #NEWFILM
	LDY #NEWFILM/256
	JSR PRTSTR
	JSR PACTFN
	JSR CRLF
	LDA #PROMPT1
	LDY #PROMPT1/256
	JSR PRTSTR
	JSR WAITKEY

INITX	JSR CLEARSCR	;clear screen
	LDA #LLEN
	LDY #00
	JSR INCTEND	;set TXTEND=BUFFER + LLEN
	CLC
	RTS


RESVEC	LDA #0		;init file variables
	STA MODE
	STA CFLAG
	STA LINNR
	STA LINNR+1
	STA CURPOS
	STA PNT
	STA PNT+1
	STA ERRCNT
	STA ERRCNT+1
	JSR SETLIN0
	STA TXTEND	;set TXTEND = BUFFER
	STY TXTEND+1
	RTS


WAITKEY	LDA #$FF
	LDX #CONIO	;wait for key
	JMP BDOS


GETCHR	LDA #$FF	;get chr from TTY
	LDX #CONIO
	JSR BDOS
TSTCHR	CMP #$20
	BCS GETCHR1
	SEC		;CTRL code
	RTS

GETCHR1 AND #$7F
	CLC		;ASCII chr
	RTS


INCLINE	JSR INCLIN	;inc LINE by LLEN+1
	STY LIN1
	STA LIN1+1

CHKTXE	CMP TXTEND+1	;check Y/A for > TXTEND
	BCC CHKTXE1
	BNE CHKTXE2
	CPY TXTEND
	BCC CHKTXE1
CHKTXE2	SEC		; > TXTEND
CHKTXE1	RTS		; < TXTEND


INCLIN	CLC
	LDA #LLEN+1
	ADC LINE
	TAY
	LDA #0
	ADC LINE+1
	RTS


DECLINE	SEC		;dec LINE by LLIN+1
	LDA LINE
	SBC #LLEN+1
	STA LIN1
	TAY
	LDA LINE+1
	SBC #0
	STA LIN1+1
CHKBUF	CMP #BUFFER/256	;check Y/A for < BUFFER
	BCC CHKBUF1
	BNE CHKBUF2
	TYA
	CMP #BUFFER
	BCC CHKBUF1
CHKBUF2	CLC
	RTS

CHKBUF1	SEC
	RTS


LINE2LIN1		;LIN1=LINE
	LDA LINE
	STA LIN1
	LDA LINE+1
	STA LIN1+1
	RTS


LIN12LINE		;LINE=LIN1
	LDY LIN1
	LDA LIN1+1
LIN12L	STY LINE
	STA LINE+1
	RTS


SETLIN0	LDA #BUFFER	;set LINE = BUFFER
	STA LINE
	LDY #BUFFER/256
	STY LINE+1
	RTS

	
SETLN1	CLC			;set LIN1=LINE+1
	LDA LINE
	ADC #1
	STA LIN1
	LDA LINE+1
	ADC #0
	STA LIN1+1
	RTS


INCTEND	CLC		;INC TXTEND by A/Y
	ADC TXTEND
	PHA
	TYA
	ADC TXTEND+1
	TAY
	PLA
	CPY HIMEM+1
	BCC INCTEN1
	CMP HIMEM
	BCC INCTEN1
	LDA #MEMOVL	;memory overflow
	RTS

INCTEN1	STA TXTEND
	STY TXTEND+1
	RTS


DECTEND	SEC		;DEC TXTEND by A/Y
	STA ABUF
	LDA TXTEND
	SBC ABUF
	PHA
	STY ABUF
	LDA TXTEND+1
	SBC ABUF
	TAY
	PLA
	CPY #BUFFER/256
	BCC DECTEN1
	BNE DECTEN2
	CMP #BUFFER
	BCC DECTEN1
DECTEN2	STA TXTEND
	STY TXTEND+1
	CLC
	RTS

DECTEN1	SEC
	RTS	
	

ILINE	LDA TXTEND	;insert line at LINE
	STA SA
	LDA TXTEND+1	;SA = old TXTEND
	STA SA+1
	LDA #LLEN+1
	LDY #0
	JSR INCTEND	;inc TXTEND
	BCS ILINEX
	LDA TXTEND	;set TA = TXTEND
	STA TA
	LDA TXTEND+1
	STA TA+1
	SEC
	LDA SA		;PNT = SA - LINE
	SBC LINE
	STA PNT
 	LDA SA+1
	SBC LINE+1
	STA PNT+1
	BCC ILINE1
	JSR MOVUP
	CLC
ILINEX	RTS

ILINE1	LDA #MEMOVL
	SEC
	RTS

	
MOVUP	LDY #0		;move PNT bytes from SA to TA
MOVUP1	LDA (SA),Y	;move it
	STA (TA),Y
	LDA SA		;dec SA
	BNE MOVUP2
	DEC SA+1
MOVUP2	DEC SA
	LDA TA		;dec TA
	BNE MOVUP3
	DEC TA+1
MOVUP3	DEC TA
	LDA PNT
	BNE MOVUP4
	DEC PNT+1
MOVUP4	DEC PNT		;dec PNT
	LDA PNT+1
	CMP #$FF	;finished?
	BNE MOVUP1
	CLC
MOVUPX	RTS


MOVDN	CLC		;move mem from TA + A/Y to TA until SA
	ADC TA
	STA PNT
	TYA
	ADC TA+1
	STA PNT+1
	LDY #0
MOVDN1	LDA (PNT),Y
	STA (TA),Y
	LDA PNT+1
	CMP SA+1
	BNE MOVDN2
	LDA PNT
	CMP SA
	BEQ MOVDNX	;SA reached?
MOVDN2	INC PNT
	BNE MOVDN3
	INC PNT+1
MOVDN3	INC TA
	BNE MOVDN1
	INC TA+1
	BNE MOVDN1

MOVDNX	RTS


CLRLINE	LDY #LLEN	;delete line at LIN1
CLRLIN1	LDA #SP
	STA (LIN1),Y
	DEY
	BPL CLRLIN1
	RTS


F1LIN	SEC		;find 1. line of actual screen
	LDA LINE
	SBC #BUFFER
	LDA LINE+1
	SBC #BUFFER/256
	AND #%11111100	;modulo $3ff = 16 lps
	CLC
	ADC #BUFFER/256
	STA LINE+1	;set LINE to 1. line
	LDA #BUFFER
	STA LINE
	RTS


Q1LIN	SEC		;is LINE the 1. line of actual screen
	LDA LINE
	SBC #BUFFER
	TAY
	LDA LINE+1
	SBC #BUFFER/256
	AND #%00000011	;modulo $3ff = 16 lps
	BNE Q1LIN1
	TYA
	AND #%11000000
	BNE Q1LIN1
	CLC		;C=0 yes it is the 1. line
	RTS

Q1LIN1	SEC		;C=1 no, its another line
	RTS


FREAD	LDX #RDSEQ	;read file to memory
	JSR BDOS	;read first sector
	BCS FREAD5
	LDY #127
FREAD2	LDA (DMA),Y	;check 127 chrs for CR
	CMP #CR
	BEQ FREAD1
	DEY
	BPL FREAD2
	LDA MODE
	ORA #%01000000	;FORTH file
	BNE FREAD3

FREAD1	LDA MODE
	AND #%10111111	;TXT file
FREAD3	STA MODE
FREAD4	JSR GNCHR	;get next chr from DMA
	BCS FREAD5
	AND #$7F	;clear MSB
	JSR CHKSTO	;check and store chr
	BCS FREAD6
FREAD7	JSR INCPNT
	BCC FREAD4
	CMP #EOF
	BEQ FREAD5
	SEC
	RTS

FREAD6	CMP #LIN2LONG	;truncate lines too long
	BEQ FREAD7
FREAD8	SEC
	RTS

FREAD5	JSR CHKSTO3	;fill line with SP
	RTS
	

CHKSTO	BIT MODE	;check chr, handle ctrl codes and store chr
	BVS CHKSTOA	;if TXT
	JSR TSTCHR
	BCS CHKSTO1
STOCHR	LDY CURPOS	;store chr
	CPY #LLEN+1	;end of line?
	BCS CHKSTO2
	STA (LINE),Y
	INY
	STY CURPOS
	RTS

CHKSTO2	LDA #LIN2LONG
	SEC
	RTS

CHKSTO1	CMP #CR		;handle ctrl codes
	BEQ CHKSTO3
	CMP #TAB
	BEQ CHKSTO4
	CMP #LF
	BEQ CHKSTO5
	JSR INCERRCNT	;inc ERRCNT
CHKSTO5	CLC
CHKSTO6	RTS

CHKSTO3	LDA #SP		;CR
	JSR STOCHR
	BCC CHKSTO3
CHKNEWL	LDY #0
	STY CURPOS
	JSR INCLIN
	STY LINE
	STA LINE+1
	LDA #LLEN+1
	LDY #0
	JSR INCTEND	;inc TXTEND
	RTS

CHKSTO4	LDA #SP		;TAB
	JSR STOCHR
	BCS CHKSTO6
	TYA
	AND #%00000111
	BNE CHKSTO4
	RTS

CHKSTOA	JSR TSTCHR	;FORTH mode
	BCS CHKSTOB
	STA ABUF
	JSR STOCHR
	BCC CHKSTOD
	JSR CHKNEWL	;inc LINE, TXTEND, CURPOS=0
	BCS CHKSTOD
	LDA ABUF
	JSR STOCHR
	BCC CHKSTOD
	CMP #MEMOVL
	BEQ CHKSTOC
CHKSTOB	JSR INCERRCNT	;inc ERRCNT
	CLC
CHKSTOD	RTS

CHKSTOC	SEC
	RTS


GNCHR	LDY PNT		;get next chr
	LDA (DMA),Y
	CMP #EOT	;EOT?
	BEQ GNCHR3
	CMP #EOT1
	BEQ GNCHR3
	CLC
	RTS

GNCHR3	LDA #EOF
	SEC		;EOF 
	RTS


INCPNT	INC PNT		;INC DMA pointer
	BEQ INCPNT1
	CLC
	RTS

INCPNT1	LDX #RDSEQ	;read next sector
	JSR BDOS
	RTS


FWRITE	LDA LINE	;write file to disc
	STA SA		;save LINE
	LDA LINE+1
	STA SA+1
	JSR SETLIN0	;start with 1. line
	LDA #0
	STA PNT		;LINE pointer = 0
	STA PNT+1	;DMA pointer = 0	
	BIT MODE
	BVS FWRITA
FWRIT5	LDY #LLEN+1	;TXT File
FWRIT1	DEY
	BMI FWRIT2	;empty line
	LDA (LINE),Y
	CMP #SP
	BEQ FWRIT1
	INY
	STY XPOS	;last chr of line+1
FWRIT3	JSR WCHR
	BCS FWRITX
	INC PNT
	LDA PNT
	CMP XPOS
	BCC FWRIT3
FWRIT2	LDA #CR
	JSR WCHR2
	BCS FWRITX
	LDA #LF
	JSR WCHR2
	BCS FWRITX
	JSR INCLINE
	BCS FWRIT4
	JSR LIN12LINE
	LDA #0
	STA PNT
	BEQ FWRIT5

FWRIT4	LDA #EOT	;write EOT
	JSR WCHR2
	BCC FWRIT8	;close file
FWRITX	RTS

FWRITA	JSR WCHR	;FORTH file
	BCS FWRITX
	INC PNT
	LDA PNT
	CMP #LLEN+1
	BCC FWRITA
	JSR INCLINE	;next line
	BCS FWRIT8
	JSR LIN12L
	LDA #0
	STA PNT
	BEQ FWRITA

FWRIT8	LDA PNT+1	;check last record not written
	BEQ FWRIT9
	TAY
	LDA #SP
FWRIT7	STA (DMA),Y	;fill rest of page with SPs
	INY
	BNE FWRIT7
	LDX #WRITE	;write last record
	JSR BDOS
	BCS FWRITX
FWRIT9	LDX #CLOSE	;close file
	JSR BDOS
	BCS FWRITX
	LDA SA
	STA LINE
	LDA SA+1
	STA LINE+1
	RTS


WCHR	LDY PNT		;write 1 chr
	LDA (LINE),Y
WCHR2	LDY PNT+1
	STA (DMA),Y
	INC PNT+1
	BEQ WCHR1
	CLC
	RTS

WCHR1	LDX #WRITE
	JSR BDOS
	RTS	


INCERRCNT		;inc error counter
	INC ERRCNT
	BNE INCEC1
	INC ERRCNT+1
INCEC1	RTS


GETFN	JSR CLEARSCR	;get filename
	JSR ACTFN	;print actual filename
	LDX #GETLIN
	JSR BDOS
	LDY #0
	LDA (INBUF),Y
	CMP #1		;check length of input string
	BEQ GETFN1
	CLC
	RTS

GETFN1	LDA #MISPAR	;no input
	SEC
	RTS


ACTFN	JSR PACTFH	;print header & filename.ext
	LDA #FILNM1
	LDY #FILNM1/256
	JSR PRTSTR	;prompt for new fileneme
	RTS


PACTFH	LDA #FILNAMM	;print header & filename.ext
	LDY #FILNAMM/256
	JSR PRTSTR

PACTFN	LDY #0		;print filename.ext in FCB1
	LDA (FCB1),Y
	CLC
	BNE PACTFN3
	LDX #DEFDRV
	JSR BDOS
	SEC
PACTFN3	ADC #'@
	JSR PRTCHR
	LDA #':
	JSR PRTCHR
PACTFN1	INY
	LDA (FCB1),Y
	JSR PRTCHR
	CPY #8
	BCC PACTFN1
	LDA #'.
	JSR PRTCHR
PACTFN2	INY
	LDA (FCB1),Y
	JSR PRTCHR
	CPY #11
	BCC PACTFN2
	CLC
	RTS


SETFCB	JSR RESFCB		;RESET FCB1
	LDY #1			;PNT is input buffer pointer
	STY XBUF		;XBUF is FCB pointer
	DEY
	STY PNT
	LDA (INBUF),Y
	STA PNT+1		;chrs in inbuf
SETFCB3	JSR GNICHR		;get next chr from inbuf
	BCS SETFCB7
	CMP #SP			;ignore leading SPs
	BEQ SETFCB3
	LDY PNT			;check for :
	INY
	CPY PNT+1
	BCS SETFCBA
	STA ABUF
	LDA (INBUF),Y
	CMP #':
	BEQ SETFCB9
	LDA ABUF
	BNE SETFCBA

SETFCB9	INC PNT
	LDA ABUF		;get drive chr
	AND #$5F		;upper case
	CMP #'A
	BCC SETFCB6
	CMP #'I
	BCS SETFCB6
	AND #$0F
	LDY #0
	STA (FCB1),Y		;set drive byte
SETFCB2	JSR GNICHR		;get next chr from INBUF
	BCS SETFCB7
	CMP #'.
	BEQ SETFCB4
SETFCBA	LDY XBUF
	STA (FCB1),Y
	INC XBUF
	CPY #8
	BNE SETFCB2
	JSR GNICHR		;after 8 chr's there must be a '.
	BCS SETFCB7		;or a valid end of filename
	CMP #'.
	BNE SETFCB5
	LDY XBUF
SETFCB1	CPY #13
	BCC SETFCB2
SETFCB5	JSR RESFCB
SETFCB6	LDA #ILLPAR
	SEC
	RTS

SETFCB4	LDY XBUF			;process '.
	CPY #9
	BCS SETFCB5
	LDY #9
	STY XBUF
	BNE SETFCB2

SETFCB7	CMP #SP 			;check for end of filename
	BEQ SETFCB8
	CMP #EOL
	BNE SETFCB5
SETFCB8	CLC
	RTS

	BEQ SETFCB2


GNICHR	LDY PNT		;GET NEXT CHR FROM INBUF
	INY
	CPY PNT+1
	BCS GNICHRX
	LDA (INBUF),Y
	STY PNT
	JSR CHRCHK
	RTS

GNICHRX	LDA #EOL
	RTS


CHRCHK	LDY #KEYTX-KEYTAB-1 	;CHECK FOR VALID CHR
CHRCHK2	CMP KEYTAB,Y		;check KEYTAB first
	BEQ CHRCHK3
	DEY
	BPL CHRCHK2
	CMP #'-
	BCC CHRCHK5		;-./0123456789:
	CMP #';
	BCC CHRCHK4
	AND #$5F		;LOWER TO UPPER CASE
	CMP #'A			;A..Z
	BCC CHRCHK5
	CMP #'[
CHRCHK4	RTS

CHRCHK3	CLC
	RTS

CHRCHK5	SEC
	RTS


RESFCB	LDY #11 	;RESET FCB
	LDA #SP
RESFC1	STA (FCB1),Y
	DEY
	BNE RESFC1
	LDA #0
	STA (FCB1),Y	;SET DRIVE NR
	RTS


P2EOL	LDY #LLEN	;print to end of line
	CPY CURPOS
	BEQ P2EOL6
	BIT CFLAG	;last chr needs to be printed
	BMI P2EOL3
P2EOL1	LDA (LINE),Y
	CMP #SP		;tuncate trailing spaces
	BNE P2EOL3
	DEY
	BPL P2EOL1
	JSR CLEARL	;clear to EOL
	INY		;CURPOS = 0
	STY CURPOS
	SEC		;line empty
	RTS

P2EOL2	CPY CURPOS
	BNE P2EOL3
P2EOL6	CLC		;is last chr -> no action
	RTS

P2EOL3	INY		;save pos of last chr
	STY XPOS
	LDY CURPOS
P2EOL4	LDA (LINE),Y	;print till ent of text
	JSR PRTCHR
	INY
	CPY XPOS
	BCC P2EOL4
	BIT CFLAG
	BVC P2EOL5	;last chr needs to be erased
	LDA #SP
	JSR PRTCHR
	INY
P2EOL5	LDA #BS
	JSR CTLOUT	;and cursor back to CURPOS
	DEY
	CPY CURPOS
	BNE P2EOL5
	LDA CFLAG	;reset CFLAG
	AND #%00111111
	STA CFLAG
	CLC
	RTS


CHK_LC	LDA (LINE),Y	;check if last chr is printable&penult is SP
	CMP #SP
	BEQ CHK_LC1
	DEY
	LDA (LINE),Y
	INY
	CMP #SP
	BNE CHK_LC1
	JSR SETLC	;set LC bit
	RTS


CHK_LC1	LDA CFLAG	;reset LC bit
	AND #%01111111
	STA CFLAG
	RTS


SETLC	LDA CFLAG	;set LC bit
	ORA #%10000000
	STA CFLAG
	RTS

OUTVT	LDY #VT-VTTAB	;print cursor up
	BNE VT_OUT

OUTLF	LDA #LF		;print LF
	JMP CTLOUT

FSOUT	LDY #HOME-VTTAB	;HOME command
	BNE VT_OUT

CLEARL	LDY #CLL-VTTAB	;HOME command
	BNE VT_OUT


CLEARSCR		;clear screen & reset pointers
	LDY # CLS-VTTAB
	JSR VT_OUT
	LDA #0
	STA CURPOS	;cursor in row 1
	CLC
	RTS


VT_OUT	LDA VTTAB,Y	;print VT ESC sequence
	BEQ VTOUTX
	JSR CTLOUT
	INY
	BNE VT_OUT

VTOUTX	RTS


CURZERO	LDA #0		;set cursor to begin of line
	STA CURPOS
	LDA #CR		;CR is non destructive on VT terminals

CTLOUT	LDX #CONIO	;print control chr
	JMP BDOS
	

ERROR	STA ERRNO	;ERROR ROUTINE
	JSR CRLF
	LDA #ERRTAB	;SET CCPV
	STA CCPV
	LDA #ERRTAB/256
	STA CCPV+1
	LDY #0		;CHECK ERROR CODE
	LDA (CCPV),Y
ERROR1	BEQ ERROR4	;END OF ERROR ROUTINE
	CMP ERRNO
	BEQ ERROR3
ERROR2	JSR INCCPV	;SKIP ERROR MESSAGE
	BNE ERROR2
	JSR INCCPV
	JMP ERROR1

ERROR3	JSR INCCPV
	PHA
	JSR ERRTYP	;PRINT ERROR TYPE
	JSR INCCPV
	LDA CCPV	;PRINT ERROR MESSAGE
	LDY CCPV+1
	JSR PRTSTR
	PLA
	BPL ERROR5
	JSR ASKRTY	;ASK FOR RETRY
	LDA ERRNO
	RTS

ERROR4	JSR UETYP	;UNKNOWN ERROR
ERROR5	SEC
	RTS


ERRTYP	LDY #0		;PRINT ERROR TYPE
ERRTY1	LSR A
	BCS ERRTY2
	INY		;X=X+5
	INY
	INY
	INY
	INY
	BNE ERRTY1

ERRTY2	LDA ETYPTB,Y
	BEQ UETYP	;LAST CHR?
	JSR PRTCHR
	INY
	BNE ERRTY2

UETYP	LDA #ERRM1
	LDY #ERRM1/256
	JSR PRTSTR
	LDA ERRNO
	JSR PRTHEX

CRLF	LDA #CRLFM
	LDY #CRLFM/256

PRTSTR	LDX #STROUT
	JMP BDOS


PRT2SP	JSR PRTSP


PRTSP	LDA #SP


PRTCHR	LDX #CONOUT	;PRINTS A CHR
	JMP BDOS


INCCPV	INC CCPV	;INC CCPV
	BNE INCCP1
	INC CCPV+1
INCCP1	LDA (CCPV),Y
	RTS


ASKRTY	LDA #RTYMES	;RETRY?
	LDY #RTYMES/256
	JSR PRTSTR
	LDX #CONIN
	JSR BDOS
	JSR UPCASE
	CMP #'Y
	BNE ASKRT1
	CLC
	RTS

ASKRT1	SEC
	RTS

UPCASE	CMP #'a 	;LOWER --> UPPER CASE
	BCC UPCASX
	CMP #'~
	BCS UPCASX
	AND #$5F
UPCASX	RTS


PRTHEX	PHA
	LSR A
	LSR A
	LSR A
	LSR A
	JSR PRTNIB
	PLA
	AND #$0F

PRTNIB	CMP #$0A
	BCC PRTNI1
	ADC #6
PRTNI1	ADC #$30
	JSR PRTCHR
	RTS



;======	TABLES ====== 

CMDTAB	DD Noop-1,PAGEDN-1,Noop-1,DEBUG-1,CURR-1,CURUP-1,PWORD-1,DELCHAR-1
	DD CURL-1,CURR-1,CURDN-1,CURUP-1,RDFILE-1,RETURN-1,Noop-1,Noop-1
	DD Noop-1,QUIT-1,PAGEUP-1,CURL-1,Noop-1,UPDSCR-1,TOGINS-1,WFILE-1
	DD CURDN-1,DELLINE-1,Noop-1,HELP-1,Noop-1,Noop-1,Noop-1,TOGTXT-1

KEYTAB	DB '!#$&+@^_'
KEYTX	

VTTAB
CLS	DB ESC,'[2J'
HOME	DB ESC,'[H',EOT
CLREOL	DB ESC,'K',EOT
CLL	DB ESC,'[2K',EOT
VT	DB ESC,'M',EOT

;======	MESSAGES ====== 

ERRM1	DB ' Error $',EOT
RTYMES	DB CR,LF,'Retry	(Y/N) ? ',EOT

ETYPTB	DB 'BIOS',$00,'BDOS',$00,'CCP',$00,$00
	DB 'RSX',$00,$00,'USER',$00

ERRTAB	DB $F9,$01,'Invalid Drive',EOT
	DB $DE,$82,'Directory full',EOT
	DB $DD,$82,'File not found',EOT
	DB $DC,$02,'File exists',EOT
	DB $D9,$02,'Invalid FCB',EOT
	DB $D8,$82,'Disk full',EOT
	DB $D6,$82,'File is R/O',EOT

	DB $80,$10,'Unknown Command',EOT
	DB $81,$10,'Memory full',EOT
	DB $82,$10,'Line too long',EOT
	DB $83,$10,'Illegal input',EOT
	DB $84,$10,'missing parameter',EOT
	DB $00

PROMPT	DB CR,LF,'EDIT V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30
PROMPT1	DB '     Press any key ',EOT

FILNAMM	DB '     Actual Filename: ',EOT

FILNM1	DB '  new filename: ',EOT

NEWFILM DB CR, LF, '  new File: ',EOT

CRLFM	DB CR,LF,EOT

HELPM	DB '	EDIT V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30
	DB '	                 (c) 06.12.22',CR,LF
	DB 'Command Summary:',CR,LF
	DB ' CTL-L	load filename.ext   '
	DB ' CTL-W      write filename.ext',CR,LF
	DB ' CTL-F	jump to next word   '
	DB ' CTL-U      update screen',CR,LF
	DB ' CTL-Y	del line            '
	DB ' CTL-G      del chr',CR,LF
	DB ' CTL-A	next page           '
	DB ' CTL-R      previous page',CR,LF
	DB ' CTL-V	toggle OW/INS       '
	DB ' CTL-#/4    toggle TXT/FORTH',CR,LF
	DB ' ESC	prints this screen  '
	DB ' CTL-Q      quit to CP/M',CR,LF,CR,LF
	DB EOT

INSERTM	DB '   INS  ',EOT
OWM	DB '   OW   ',EOT
FORTHM	DB '   FORTH ',EOT
TEXTM	DB '   TEXT  ',EOT

Buffer	DS $100,SP

	END
