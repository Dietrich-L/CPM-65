;FLOPPY DISK BIOS FUER DIE UDC-KARTE
;NACH ELEKTOR COMPUTING 6

;D. LAUSBERG	(C) 1987
;V1.2	11.11.88
;V1.3	13.12.89	PRINTER ROUTINES
;V1.4	14.06.90	NEW PARAMETERS
;V1.5	14.10.90	IMPROVEMENTS
;V1.6	10.11.91	ASM-65 EXTENDED VERSION
;V2.0	20.11.91	IRQ BASED VERSION
;V2.1	27.05.92	BOOT ROM VERSION
;V2.2	18.06.92	INCREASED SPEED, FORMAT TRACK
;V2.3	09.03.93	DOUBLE DRIVE
;V2.4	21.02.95	new memory map
;V2.5	27.03.95	SCSI support
;V2.6	09.12.95	2 logical SCSI discs
;V2.7	26.07.98	slightly modified memory map
;V2.8	30.06.00	change to sector bios
;V2.9	08.11.02	disk parameters corrected
;V2.A	25.03.21	4 Floppies + 2 HD Drives
;V2.B	30.05.21	SCSI2SD corrections interim fix, I2C commands
;V3.0	07.02.22	BOOTPROM v3.0 version

VERSION	= $30		;VERSION NUMBER

;FORMAT	DS/DD	320 KBYTES/DISK
;SCSI2HD	2x 16 MBytes on SCSI ID1
;=====================================

;PAGE 00 CELLS

DMAV	= $FE		;DMA-VECTOR
DIRBFV	= $FC		;DIRBF-VECTOR
BIOSP	= $FA		;BIOS-POINTER
DPHV	= $F8		;DPH-VECTOR
JPBDOS	= $F0

;SYSTEM CONSTANTS

CCP	= $D800
BEGIN	= $E400

ROM_CONST = $F806
ROM_CONIN = $F809
ROM_CONOUT = $F80C
ROM_LIST  = $F80F
ROM_LISTST = $F80A
ROM_MONITOR = $F830
ROM_SET_TIMER1 = $F833
ROM_GET_TIMER1 = $F836
ROM_SET_TIMER2 = $F839
ROM_GET_TIMER2 = $F83C
ROM_I2CCLR = $F83F		; 15
ROM_I2CSTOP = $F842		; 16
ROM_I2CPOLL = $F845		; 17
ROM_I2CADEV = $F848		; 18
ROM_I2CR16 = $F84B		; 19
ROM_I2CRDEV = $F84E		; 1A
ROM_I2CWByte = $F851		; 1B
ROM_I2CRByte = $F854		; 1C
ROM_I2CRLB = $F857		; 1D

ROM_I2CGTime = $F85D		; 1F
ROM_I2CGDate = $F860		; 20

;UDC-CONTROLLER ADDRESSES

UDC	= $F500
SCSI_D	= UDC		;SCSI Data Port
SCSI_ST	= UDC+$10	;SCSI Status Port
SCSI_SE	= UDC+$20	;SCSI Select Register
SCSI_R	= UDC+$30	;SCSI Reset Port
FDSEL	= UDC+$40	;MOTOR/SELECT DRIVE LATCH
FDSCR	= UDC+$50	;READ STATUS, WRITE COMMAND
FDTRG	= UDC+$51	;R/W TRACK REGISTER
FDSRG	= UDC+$52	;R/W SECTOR REGISTER
FDDAR	= UDC+$53	;R/W DATA REGISTER
FLSTAT	= UDC+$60	;IRQ --> BIT 7, DRQ --> BIT 6

;VIA ADDRESSES

DRA	= $F401
DDRA	= $F403
PCR	= $F40C
IFR	= $F40D
IER	= $F40E

;6532 ADDRESSES

SCRATCH	= $F600

I2CDEV	= SCRATCH+$4B		;I2C device nr 7 Bit
ID	= SCRATCH+$4C		;I2C memory data set ID
PNT16	= SCRATCH+$4E		;I2C 16 bit register
ADR	= SCRATCH+$50		;I2C adress pointer
ENDADR	= SCRATCH+$52		;I2C end adress
STPRATE	= SCRATCH+$54		;Steprate $00: 6ms, $01: 12 ms
COMBUF	= SCRATCH+$5A		;6 Byte SCSI Command Buffer
MODE	= SCRATCH+$60		;MODE SWITCH FOR HEX MONITOR & Buffer for FD_ST
KEY	= SCRATCH+$61		;KEY BUFFER FOR HEX KEYBOARD
TIME	= SCRATCH+$62		;8 BIT TIME FOR ELEKTERMINAL
XBUF	= SCRATCH+$63
CHARBUF	= SCRATCH+$64
CHR	= SCRATCH+$65
ABUF	= SCRATCH+$66		;ACCU BUFFER FOR IRQ ROUTINE
SCSI_B	= SCRATCH+$67		;SCSI BLOCK BUFFER (H/M/L)

SCSI_F	= SCRATCH+$6A		;SCSI FLAG BIT7 = dirty
DRIVE	= SCRATCH+$6B
TRACK	= SCRATCH+$6C		;TRACK BUFFER FOR ROM-BIOS
SECTOR	= SCRATCH+$6D		;SECTOR BUFFER FOR ROM-BIOS
SIDEMS	= SCRATCH+$6E		;SIDE MASK	SIDE 1 =  $02
RETRY	= SCRATCH+$6F		;RETRY COUNTER
ERRCOD	= SCRATCH+$70		;ERROR CODE
TIMER0	= SCRATCH+$71		;SYSTEM TIMER
TIMER1	= SCRATCH+$72		;8 BIT USER TIMER
TIMER2	= SCRATCH+$73		;16 BIT USER TIMER
SECS	= SCRATCH+$75		;BIOS Sector Buffer $75 .. $77
UIRQV	= SCRATCH+$78		;&F678
NMIV 	= SCRATCH+$7A		;$F67A
BREAKV	= SCRATCH+$7C		;$F67C
IRQV	= SCRATCH+$7E		;$F67E

PAD	= $F680
PADD	= $F681
PBD	= $F682
PBDD	= $F683
RIOFLAG	= $F6D5		;RIOT FLAG REGISTER
TI1024K	= $F6FF		;TIMER 1024K IRQ ENABLE

;CONTROL CODES

BREAKC	= $03		;BREAK CODE
CLS	= $0C		;CLEAR SCREEN

;ERROR CODES

SCSI_TIMEOUT = $F7
SCSI_ERROR = $F6
I2CError = $F5
NO_DEV	= $F4
ID_NFND	= $F3

;WD 2797 COMMANDS

RDSECC	= $88		;READ SECTOR
WRSECC	= $A8		;WRITE SECTOR
RSTORC	= $00		;RESTORE, steprate 6 ms
SEEKC	= $18		;SEEK WITHOUT VERIFY, steprate 6 ms

;SCSI COMMANDS

RD_COM	= $08		;SCSI READ BLOCK
WR_COM	= $0A		;SCSI WRITE BLOCK
SENSE_COM = $03		;SCSI SENSE STATUS

;I2C adresses
RTC	= $68
24C32	= $57

;CONSTANTS

SELMSK	= $10		;MOTOR ON, DDEN ON
MAXTRK	= 80		;MAX TRACKS

SPT	= 16		;SECTORS PER TRACK
SPTDIV	= 4		;log(2) SPT
SPB	= 4		;SECTORS PER BLOCK
SPBDIV	= 2		;LOG(2) SPB
SYS	= 32		;SYSTEM sectors
BPD	= MAXTRK*SPT-SYS/SPB-1	;BLOCKS PER DISK
DIRSCS	= 16		;DIRECTORY SECTORS
DIRMSK	= %11111111	;DIR MASK FOR BAT
RPEXT	= 8*SPB*2 	;RECORD PER EXTENT
BATSIZ	= BPD/8		;SIZE OF BAT

DIRSCSC	= 32		;Directory sectors SCSI

MAXTRY	= 10		;MAX TRIES ON ERROR

;==========================================

	ORG BEGIN

FBIOS	JMP BOOT		; 00
	JMP WBOOT		; 01
	JMP ROM_CONST		; 02
	JMP ROM_CONIN		; 03
	JMP ROM_CONOUT		; 04
	JMP ROM_LIST		; 05
	JMP AUXOUT		; 06
	JMP AUXIN		; 07
	JMP HOME		; 08
	JMP SELDSK		; 09
	JMP SETTRK		; 0A
	JMP SETSEC		; 0B
	JMP READ		; 0C
	JMP WRITE		; 0D
	JMP ROM_LISTST		; 0E
	JMP GET_VERSION		; 0F
	JMP ROM_MONITOR		; 10
	JMP ROM_SET_TIMER1	; 11
	JMP ROM_GET_TIMER1	; 12
	JMP ROM_SET_TIMER2	; 13
	JMP ROM_GET_TIMER2	; 14
	JMP ROM_I2CCLR		; 15
	JMP ROM_I2CSTOP		; 16
	JMP ROM_I2CPOLL		; 17
	JMP ROM_I2CADEV		; 18
	JMP ROM_I2CR16		; 19
	JMP ROM_I2CRDEV		; 1A
	JMP ROM_I2CWByte	; 1B
	JMP ROM_I2CRByte	; 1C
	JMP ROM_I2CRLB		; 1D
	JMP I2CLOADID		; 1E
	JMP ROM_I2CGTime	; 1F
	JMP ROM_I2CGDate	; 20

;========== DATA AREA =============

DPHA	DW DIRBF	;DISK PARAMETER HEADER
	DW DMA		;FOR DRIVE A to D
	DW BAT

	DB SPB-1	;DISK PARAMETER BLOCK FOR DISK A
	DB SPBDIV
	DW BPD
	DB DIRSCS
	DB DIRMSK
	DB RPEXT
	DB SYS,0,0
	DB BATSIZ


DPHE	DW DIRBF	;Disk Parameter Header for Drive E
	DW DMA
	DW BAT

	DB 31		;SPB	DISK PARAMETER BLOCK
	DB  5		;SPBDIV
	DW $7FE		;BPD
	DB DIRSCSC	;DIRSCSC is used in SCSI_WR
	DB %10000000	;DIRMSK
	DB $80		;RPEXT
	DB SYS,0,0	;SYS
	DB $7FF/8	;BATSIZ

DPHF	DW DIRBF	;Disk Parameter Header for Drive F
	DW DMA
	DW BAT

	DB 31		;SPB	DISK PARAMETER BLOCK
	DB  5		;SPBDIV
	DW $7FF		;BPD
	DB DIRSCSC	;DIRSCSC is used in SCSI_WR
	DB %10000000	;DIRMSK
	DB $80		;RPEXT
	DB $00,$00,$01	;SYS
	DB $7FF/8	;BATSIZ

BAT	DB %10000000	;Block Allocation Table Drive A-F
	DS $FF		;max. 1 page


;--- DRIVE TABLE Floppy Drives---

DRVTAB	DB $01,$02,$04,$08		;DRIVE Select TABLE
TRKTAB	DB 0,0,0,0			;TRACK TABLE

;--- ERROR TABLES---

SETAB	DB $FE,$08,$FF,$10
	DB $FA,$04,$FE,$08,$FB,$10,$FC,$40,$FD,$80

;--- I2C load commands -----

SET_SRATE
	DB $57			;EEPROM adr
	DW $8001		;ID
	DW STPRATE		;steprate bytes memory location


;==================================

BOOT	LDA #$4C		;SET JMP BDOS
	STA JPBDOS
	LDA #CCP
	STA JPBDOS+1
	LDA #CCP/256
	STA JPBDOS+2
	LDA #%00001010		;SET VIA PORT A FOR CENTRONICS
	ORA PCR			;CA1 = /BUSY
	STA PCR
	LDA #%00000011
	STA IER
	STA IFR
	LDA #%11111111
	STA DDRA
	JSR SCSI_RST		;reset SCSI
	LDA PADD	
	ORA #%00000001		; PA0 is Output for I2C SCL
	STA PADD
	JSR ROM_I2CCLR		;reset I2C
	JSR SSRATE		;set steprates
	JSR HOME		;HOME BOOT DISK
	LDA DRIVE		;SELECT BOOT DRIVE
	LDX #$0E		;VIA BDOS
	JSR JPBDOS
	LDX #0 			;WARM BOOT
	JMP JPBDOS


WBOOT	LDA DRIVE		;SELECT DEFAULT DRIVE
	JSR SELDSK
	RTS


;---	CONST	JMP ROM_CONST


;---	CONIN	JMP ROM_CONIN


;---	CONOUT	JMP ROM_CONOUT


;---	LIST	JMP ROM_LIST	


AUXOUT	RTS

AUXIN	RTS


HOME	LDA DRIVE
	CMP #4			;Check for Drive > D
	BCS HOME2
	JSR DRVSEL		;HOMES TO TRACK 0
HOME0	JSR READY
	BCS HOMEX
	JSR RESTORE		;RESTORE DRIVE
	BCS HOMEX
	STA ERRCOD
	AND #%10011001		;MASK SEEK ERROR
	BNE HERR1
	STA TRACK		;SET TRACK=0
HOME2	CLC
HOMEX	RTS

HERR1	JSR ERROR		;CHECK ERROR COUNT
	BCC HOME0		;RETRY
	JMP SERR		;CONT WITH SEEK ERROR


SELDSK	CMP #4			;TEST FOR DRIVE A to D
	BCS SELDS1
	STA DRIVE		;SELECT DISK LOGICAL
	LDA #DPHA		;SET DPHVEC
	STA DPHV
	LDA #DPHA/256
	STA DPHV+1
	CLC
	RTS

SELDS1	CMP #4			;TEST FOR DRIVE E
	BNE SELDS2
	STA DRIVE		;SELECT DISK E LOGICAL
	LDA #DPHE		;SET DPHVEC
	STA DPHV
	LDA #DPHE/256
	STA DPHV+1
	CLC
	RTS


SELDS2	CMP #5			;TEST FOR DRIVE F
	BNE SELDS3
	STA DRIVE		;SELECT DISK F LOGICAL
	LDA #DPHF		;SET DPHVEC
	STA DPHV
	LDA #DPHF/256
	STA DPHV+1
	CLC
	RTS

SELDS3	LDA #$F9		;ILLEGAL DRIVE NR
	SEC
	RTS


SETSEC	TAX			;sector pointer for p.00 in Accu
	LDA 0,X
	STA SECS
	LDA 1,X
	STA SECS+1
	LDA 2,X
	STA SECS+2
	RTS


SETTRK	LDA #$FB		;Sector not found
	SEC
	RTS


READ	LDA DRIVE
	CMP #4			;CHECK FOR DRIVE > D
	BCS SCSI_RD

READ4	JSR DRVSEL		;READ SECTOR TO DMA
	JSR FD_ST		;convert sec nr to sector/track
	BCS READX
READ0	JSR SEEKTR		;SELECT DRIVE AND SET TRACK
	BCS READX
	LDA SECTOR		;SET SECTOR
	STA FDSRG
	LDA #RDSECC
	ORA SIDEMS		;SET SIDE BIT
	SEI
	STA FDSCR		;READ SECTOR
	JSR DELAY
	LDY #0
READ1	BIT FLSTAT		;GET STATUS
	BMI READ2		;DONE
	BVC READ1		;NO DATA
	LDA FDDAR		;GET BYTE
	STA (DMAV),Y
	INY
	JMP READ1

READ2	JSR DELAY
	CLI
	LDA FDSCR
	STA ERRCOD
	AND #%11011111		;MASK ERROR
	BNE READ3
	LDA #0			;RESET RETRY COUNTER
	STA RETRY
	CLC
READX	RTS

READ3	JSR ERROR
	BCC READ0		;REREAD
	BCS WRITE4


SCSI_RD	JSR SETBLK		;SET BLK NR IN COMBUF
	JSR CHKBLK		;CHECK IF BLOCK VALID
	BCC SCSIRD1
	JSR S_READ
	BCS SCSIRDX
SCSIRD1	LDA SECS
	LSR A
	LDY #0
	BCS SCSIRD3
SCSIRD2	LDA SCSIBUF,Y
	STA (DMAV),Y
	INY
	BNE SCSIRD2
	CLC
	RTS

SCSIRD3	LDA SCSIBUF+256,Y
	STA (DMAV),Y
	INY
	BNE SCSIRD3
	CLC
SCSIRDX	RTS


WRITE	LDA DRIVE
	CMP #4			;CHECK FOR DRIVE > D
	BCS SCSI_WR

WRITE5	JSR DRVSEL		;WRITE SECTOR IN DMA
	JSR FD_ST		;convert sec nr to sector/track
	BCS WRITEX
WRITE0	JSR SEEKTR		;SET DRIVE AND TRACK
	BCS WRITEX
	LDA SECTOR
	STA FDSRG		;SET SECTOR
	LDA #WRSECC
	ORA SIDEMS		;SET SIDE BIT
	SEI
	STA FDSCR		;WRITE SECTOR
	JSR DELAY
	LDY #0
WRITE1	BIT FLSTAT		;GET STATUS
	BMI WRITE2		;DONE
	BVC WRITE1		;NO DATA
	LDA (DMAV),Y
	STA FDDAR
	INY
	JMP WRITE1

WRITE2	JSR DELAY
	CLI
	LDA FDSCR		;GET STATUS
	STA ERRCOD
	BNE WRITE3
	LDA #0			;RESET RETRY COUNTER
	STA RETRY
	CLC
WRITEX	RTS

WRITE3	JSR ERROR
	BCC WRITE0		;REWRITE
WRITE4	LDY #13
	JMP FDERR

SCSI_WR	JSR SETBLK		;WRITE SCSI
	JSR CHKBLK
	BCC SCSIWR1
	JSR S_READ		;write implicitely
	BCS SCSIWRX		;when SCSI buffer dirty
SCSIWR1	LDA SECS
	LSR A
	LDY #0
	BCS SCSIWR2
SCSIWR3	LDA (DMAV),Y
	STA SCSIBUF,Y
	INY
	BNE SCSIWR3
	BEQ SCSIWR4

SCSIWR2	LDA (DMAV),Y
	STA SCSIBUF+256,Y
	INY
	BNE SCSIWR2	
SCSIWR4	LDA #$80
	STA SCSI_F		;SCSIBUF dirty
	LDA COMBUF+3
	CMP #DIRSCSC/2		
	BCS SCSIWR5
	JSR SCSI_WB		;write SCSI block immediate
SCSIWRX	RTS

SCSIWR5	CLC
	RTS


;---	JMP ROM_LISTST



GET_VERSION			;GET VERSION NUMBER

	LDA #VERSION
	RTS


;---	JMP ROM_SET_TIMER1


;---	JMP ROM_GET_TIMER1


;---	JMP ROM_SET_TIMER2


;---	JMP ROM_GET_TIMER2


;--------- I2C Commands ------------------------------

;---	JMP ROM_I2CCLR	;clear I2C-Bus


;---	JMP ROM_I2CADEV	;send 7 bit dev adr to write


;---	JMP ROM_I2CR16	;send word L/H in ZP,A to dev


;---	JMP ROM_I2CRDEV	;send 7 bit dev adr to read


;---	JMP ROM_I2CWByte ;write byte in A to dev


;---	JMP ROM_I2CRBYTE ;read byte from dev


;---	JMP ROM_I2CRLB	;read last byte from dev


I2CLOADID		;load ID data to memory
	TAX
	LDA 0,X		;set parameters
	STA I2CDEV
	LDA 1,X
	STA ID
	LDA 2,X
	STA ID+1
	LDA 3,X
	STA ADR
	LDA 4,X
	STA ADR+1
	LDY #0		;start with dev adr = 0
	STY PNT16
	STY PNT16+1
LDID3	JSR RESDMA
	CLC		;ENDADR = DMA + 4
	ADC #4		;read 4 bytes header
	STA ENDADR
	BCC LDID4
	INX
LDID4	STX ENDADR+1
	JSR RDBLK	;read header to DMA
	BCS LDIDX
	LDA PNT16	;dev adr = dev adr + 4
	ADC #4
	STA PNT16
	BCC LDID5
	INC PNT16+1
LDID5	JSR RESDMA	;DMA = ADR
	LDY #1
	LDA (DMAV),Y
	TAX
	DEY
	LDA (DMAV),Y
	CMP #$FF
	BNE LDID1
	CPX #$FF	;ID = $FFFF ?
	BNE LDID1
	LDA #ID_NFND	;ID not found
	SEC
LDIDX	RTS

LDID1	CMP ID		;ID match?
	BNE LDID2
	CPX ID+1
	BNE LDID2
	CLC
	LDY #2		;ENDADR = ADR + LENGTH
	LDA (DMAV),Y
	ADC ADR
	STA ENDADR
	INY
	LDA (DMAV),Y
	ADC ADR+1
	STA ENDADR+1
	JSR RDBLK	;read data block
	RTS

LDID2	CLC
	LDY #2		;dev adr = dev adr + LENGTH
	LDA (DMAV),Y
	ADC PNT16
	STA PNT16
	INY
	LDA (DMAV),Y
	ADC PNT16+1
	STA PNT16+1
	JMP LDID3


;---	JMP ROM_I2CGTIME ;get time to p.00 cells


;---	JMP ROM_I2CGDATE ;get date to p.00 cells


; I2C subroutines

RDBLK	LDA I2CDEV		;Read Block to Buffer
	JSR ROM_I2CADEV		;select dev for Write
	BCS RDBLKX
	LDA PNT16+1		;set 16 bit reg
	JSR ROM_I2CWByte
	BCS RDBLKY
	LDA PNT16
	JSR ROM_I2CWByte
	BCS RDBLKY
	LDA I2CDEV
	JSR ROM_I2CRDEV
	BCS RDBLKY
RDBLK1	LDY DMAV+1		;CHKEND
	CPY ENDADR+1
	BCC RDBLK2
	LDY DMAV
	CPY ENDADR
	BCS RDBLK2
	JSR ROM_I2CRBYTE	;read next byte
	BCS RDBLKX
	LDY #0
	STA (DMAV),Y
	INC DMAV
	BNE RDBLK1
	INC DMAV+1
	BNE RDBLK1

RDBLK2	JSR ROM_I2CRLB		;dummy read last byte
RDBLKX	RTS

RDBLKY	LDY #I2CERROR
	RTS

RESDMA	LDA ADR			;set DMA = ADR A/X
	STA DMAV
	LDX ADR+1
	STX DMAV+1
	RTS

;---	JMP ROM_I2CPOLL 

; basic I2C states

;---	JMP ROM_I2CStop	; I2C stop condition

;====== SUBROUTINES =======

SSRATE	LDY #4		;try to load from EEPROM
SSR1	LDA SET_SRATE,Y
	STA 0,Y
	DEY
	BPL SSR1
	LDA #0		;page $00 vector = 0
	JSR I2CLOADID
	BCC SSRX	;if not succesful
	LDY #3		;set steprates to defaults
	LDA #$01
SSR2	STA STPRATE,Y
	DEY
	BPL SSR2
SSRX	RTS

DRVSEL	LDA DRIVE		;SELECT DRIVE
	AND #$03		;MAX. 4 DRIVES
	TAY
	LDA DRVTAB,Y		;GET DRIVE BIT
	ORA #SELMSK
	STA FDSEL		;MOTOR ON
	LDA #50/2		;5 SECONDS MOTOR ON
	STA TIMER0
	RTS


FD_ST	LDA SECS		;calc sector/track from sector nr
	STA MODE
	AND #SPT-1
	STA SECTOR		;always 2^n sectors/track
	LDA SECS+2
	BNE FD_ST1		;definitely not more than $7FF Tracks!
	LDX #SPTDIV
	LDA SECS+1
FD_ST2	LSR A			;TRACK = SECS/16
	ROR MODE
	DEX
	BNE FD_ST2
	CMP #0
	BNE FD_ST1		;max. $FF TRACK's
	LDA MODE
	CMP #MAXTRK
	BCS FD_ST1
	LSR A			;set track
	STA TRACK
	LDA #0
	ROL A
	ROL A
	STA SIDEMS		;set side bit
FD_STX	RTS

FD_ST1	LDA #$FB		;sector not found error
	SEC
	RTS


SEEKTR	JSR READY		;SEEK TRACK
	BCS SEEKX
	LDY DRIVE		;SET CONTROLLER TRACK REGISTER
	LDA TRKTAB,Y		;FOR THIS DRIVE
	STA FDTRG
	LDA TRACK		;GET NEW TRACK
	STA TRKTAB,Y		;SAVE IT TO TABLE
	STA FDDAR
	LDA #SEEKC
	ORA STPRATE,Y		;set Steprate
	STA FDSCR		;AND SEEK
SEEK1	JSR READY
	BCS SEEKX
	STA ERRCOD
	AND #%10011001		;MASK SEEK ERROR
	BNE SKERR1
	CLC
SEEKX	RTS

SKERR1	JSR ERROR		;CHECK ERROR COUNT
	BCC SEEKTR

SERR	LDY #3			;SET ERROR CONDITION

FDERR	LDA ERRCOD
	AND SETAB,Y
	BNE FDERR1
	DEY
	DEY
	BPL FDERR
	SEC			;C= 1 AND A= 0
	RTS			;UNKNOWN ERROR

FDERR1	DEY
	LDA SETAB,Y		;LOAD ERROR NR
	SEC
	RTS


RESTORE	LDA #0			;RESTORE DRIVE
	LDY DRIVE
	STA TRKTAB,Y		;SET TRACK =  0
	LDA #RSTORC
	ORA STPRATE,Y		;set Steprate
	STA FDSCR		;RESTORE
	JSR READY
	RTS


ERROR	INC RETRY		;INC RETRY COUNTERS
	LDA RETRY		;NO MORE TRIES?
	CMP #MAXTRY
	BCS ERROR1		;RETRY
	LSR A
	BCC ERROR1
	JSR RESTORE
ERROR1	RTS


DELAY	JSR DELAY1		;DELAY 28 uS
DELAY1	NOP
	RTS


READY	JSR DELAY		;WAITS WHILE CONTROLLER
READY1	LDA TIMER0		;IS BUSY AND DRIVE NOT READY
	BEQ READY2
	LDA #%10000001		;MASK READY/BUSY BITS
	BIT FDSCR
	BNE READY1
	LDA FDSCR
	CLC
	RTS

READY2	LDA #$FD		;DRIVE NOT READY
	SEC
	RTS


S_READ	BIT SCSI_F		;SCSI READ
	BPL S_READ1		;if buffer dirty
	JSR S_SAVE		;SAVE SCSI BUFFER
	BCS S_READX
S_READ1	LDA #RD_COM
	STA COMBUF
	JSR S_COM		;DO SELECT AND EXEC COMMAND
	BCS S_READX
	LDA #%01101111
	JSR S_WAIT
	BCS S_READX
	LDY #0			;READ 512 BYTES
S_READ2	LDA SCSI_D
	STA SCSIBUF,Y
	INY
	BNE S_READ2
S_READ3	LDA SCSI_D
	STA SCSIBUF+256,Y
	INY
	BNE S_READ3
	JSR GET_SM		;GET SCSI STATUS
	BCS S_READX
	JSR S_UPD		;UPDATE BLK/FLAG INFO
S_READX	RTS


S_SAVE	LDA SCSI_B+2		;save old buffer
	STA COMBUF+1
	LDA SCSI_B+1
	STA COMBUF+2
	LDA SCSI_B
	STA COMBUF+3
	JSR SCSI_WB
	BCS S_SAVEX
	JSR SETBLK1		;reset blk nr
	CLC
S_SAVEX	RTS


SCSI_WB	LDA #WR_COM		;Write SCSI block pysically
	STA COMBUF		;block nr in COMBUF
	JSR S_COM
	BCS S_WBX
	LDA #%01101110
	JSR S_WAIT
	BCS S_WBX
	LDY #0			;SAVE 512 BYTES
S_WB1	LDA SCSIBUF,Y
	STA SCSI_D
	INY
	BNE S_WB1
S_WB2	LDA SCSIBUF+256,Y
	STA SCSI_D
	INY
	BNE S_WB2
	JSR GET_SM		;GET SCSI STATUS
	BCS S_WBX
	JSR S_UPD
S_WBX	RTS


SCSI_RST			;do a SCSI bus reset
	LDA #1
	STA SCSI_F		;MARK SCSI BUFFER AS INVALID
	LDA #$80		;INITIALIZE SCSI DRIVE
	STA SCSI_R
	LDX #80			;wait 0.03 ms
S_RES1	DEX
	BNE S_RES1
	TXA			;reset pulse
	STA SCSI_R
S_RES2	DEX
	BNE S_RES2
	RTS


S_UPD	LDA COMBUF+1		;UPDATE BLK NR AND SCSI FLAG
	STA SCSI_B+2
	LDA COMBUF+2
	STA SCSI_B+1
	LDA COMBUF+3
	STA SCSI_B
	LDA #0
	STA SCSI_F
	RTS


S_COM	LDA #20/2		;SET TIMEOUT TO 2 s
	STA TIMER0
	LDA #%00100110
	JSR S_WAIT
	BCS S_COMX
	LDA #1			;SELECT DRIVE 1
	STA SCSI_D
	STA SCSI_SE
	LDY #0
S_COM1	LDA #%11101110
	JSR S_WAIT
	BCS S_COMX
	LDA COMBUF,Y
	STA SCSI_D
	INY
	CPY #6
	BCC S_COM1
	CLC
S_COMX	RTS


GET_SM	LDA #%11101111		;GET STATUS AND MESSAGE
	JSR S_WAIT
	BCS GET_SMX
	LDY SCSI_D
	LDA #%11111111
	JSR S_WAIT
	BCS GET_SMX
	LDA SCSI_D
	BNE GET_SM1
	TYA
	BNE GET_SM1
	CLC
GET_SMX	RTS

GET_SM1	JSR SCSI_RST		;reset SCSI bus
	RTS


GETBYT	LDA #%01101111		;get byte from SCSI
	JSR S_WAIT
	BCS GETBYTX
	LDA SCSI_D
GETBYTX	RTS


S_WAIT	LDX TIMER0
	BEQ S_WAIT1
	CMP SCSI_ST
	BNE S_WAIT
	CLC
	RTS

S_WAIT1	LDA #SCSI_TIMEOUT
	SEC
	RTS
	

SETBLK	LDX #1
	STX COMBUF+4
	DEX
	STX COMBUF+5
SETBLK1	LDA SECS+2
	LSR A
	STA COMBUF+1
	LDA SECS+1
	ROR A
	STA COMBUF+2
	LDA SECS
	ROR A
	STA COMBUF+3
	RTS


CHKBLK	LDA COMBUF+3		;CHECK IF BLK IN BUFFER VALID
	CMP SCSI_B		;C=1 invalid
	BNE CHKBL1
	LDA COMBUF+2
	CMP SCSI_B+1
	BNE CHKBL1
	LDA COMBUF+1
	CMP SCSI_B+2
	BNE CHKBL1
	LDA SCSI_F
	LSR A
	RTS

CHKBL1	SEC
	RTS


DMA	

DIRBF	=  DMA+256

SCSIBUF	=  DIRBF+256


	END
