;BOOTPROM.ASM - EPROM-BIOS fuer den JUNIOR-COMPUTER und CP/M-65

;V1.0	22.12.91	by D. Lausberg
;V1.1	31.05.92	reset fix
;V1.2	31.05.92	boot vector fix
;V1.3	07.06.92	some corrections
;V1.4	10.01.95	dual drive support
;V1.5	20.02.95	new memory map
;V2.0	30.12.95	SCSI support
;V2.1	02.02.96	SCSI Boot delay
;V2.2	19.04.02	9600 Baud Terminal
;V2.3	27.04.21	4 Floppies + SCSI, 8 Bit serial I/O
;V2.4	01.05.21	improved SCSI, 6532 Ports
;V3.0	07.02.22	added LIST, LISTST, TIMER, I2C, CONOUT corrected
;			ohne I2C_LOADID, ca. 100 Bytes free
;V3.1	29.01.23	var speed CONio

VERSION	= $31		;VERSION NUMBER

;=====================================

;PAGE 00 CELLS

POINT	= $FA			;POINTER FOR HEX MONITOR
DMA	= $FE			;DMA-VECTOR

TPA	= $200

;SYSTEM CONSTANTS

SCSIBUF	= $F200
BEGIN	= $F800			

;UDC-CONTROLLER ADDRESSES

UDC	= $F500

SCSI_D	= UDC			;SCSI Data Port
SCSI_ST	= UDC+$10		;SCSI Status Port
SCSI_SE	= UDC+$20		;SCSI Select Register
SCSI_R	= UDC+$30		;SCSI Reset Port

FDSEL	= UDC+$40		;MOTOR/SELECT DRIVE LATCH
FDSCR	= UDC+$50		;READ STATUS, WRITE COMMAND
FDTRG	= UDC+$51		;R/W TRACK REGISTER
FDSRG	= UDC+$52		;R/W SECTOR REGISTER
FDDAR	= UDC+$53		;R/W DATA REGISTER
FLSTAT	= UDC+$60		;IRQ --> BIT 7, DRQ --> BIT 6

;VIA ADDRESSES

DRA	= $F401
DDRA	= $F403
PCR	= $F40C
IFR	= $F40D
IER	= $F40E

;6532 ADDRESSES

SCRATCH	= $F600

SPEED	= SCRATCH+$4A		;SPEED flag b7=1 38400 Bd; b6=1 19200 Bd
I2CDEV	= SCRATCH+$4B		;I2C device nr 7 Bit
ID	= SCRATCH+$4C		;I2C memory data set ID
PNT16	= SCRATCH+$4E		;I2C 16 bit register
ADR	= SCRATCH+$50		;I2C adress pointer
ENDADR	= SCRATCH+$52		;I2C end adress

BITTIME	= SCRATCH+$58		;bit delay for COM
HBTTIME	= SCRATCH+$59		;half bit delay for COM
COMBUF	= SCRATCH+$5A		;6 Byte SCSI Command Buffer  .. $5F
MODE	= SCRATCH+$60		;MODE SWITCH FOR HEX MONITOR
KEY	= SCRATCH+$61		;KEY BUFFER FOR HEX KEYBOARD
TIME	= SCRATCH+$62		;8 BIT TIME FOR ELEKTERMINAL
YBUF	= SCRATCH+$63		;Y buffer for CHRIN & CHROUT
CHARBUF	= SCRATCH+$64
CHR	= SCRATCH+$65
ABUF	= SCRATCH+$66		;ACCU BUFFER FOR IRQ ROUTINE
SCSI_B	= SCRATCH+$67		;SCSI BLOCK BUFFER (H/M/L)

SCSI_F	= SCRATCH+$6A		;SCSI FLAG
DRIVE	= SCRATCH+$6B
TRACK	= SCRATCH+$6C		;TRACK BUFFER FOR ROM-BIOS
SECTOR	= SCRATCH+$6D		;SECTOR BUFFER FOR ROM-BIOS
SIDEMS	= SCRATCH+$6E		;SIDE MASK	SIDE 1 =  $02
RETRY	= SCRATCH+$6F		;RETRY COUNTER
ERRCOD	= SCRATCH+$70		;ERROR CODE
TIMER0	= SCRATCH+$71		;SYSTEM TIMER
TIMER1	= SCRATCH+$72		;8 BIT USER TIMER
TIMER2	= SCRATCH+$73		;16 BIT USER TIMER
SECS	= SCRATCH+$75		;BIOS Sector Buffer $75 .. $77
UIRQV	= SCRATCH+$78		;$F678
NMIV 	= SCRATCH+$7A		;$F67A
BREAKV	= SCRATCH+$7C		;$F67C
IRQV	= SCRATCH+$7E		;$F67E

PAD	= $F680		;PA7 = RX
PADD	= $F681
PBD	= $F682		;PB0 = TX
PBDD	= $F683
RIOFLAG	= $F6D5			;RIOT FLAG REGISTER
TI1024K	= $F6FF			;TIMER 1024K IRQ ENABLE

;CONTROL CODES

BREAKC	= $03			;BREAK CODE
CLS	= $0C			;CLEAR SCREEN
CR	= $0D
LF	= $0A
EOT	= $00

;WD 2797 COMMANDS

RDSECC	= $88			;READ SECTOR
RSTORC	= $01			;RESTORE
SEEKC	= $19			;SEEK WITHOUT VERIFY
WRSECC	= $A8			;WRITE SECTOR

;SCSI COMMANDS

RD_COM	= $08			;SCSI READ BLOCK
SENSE_COM = $03			;SCSI SENSE STATUS

;Error Codes

NOTERM	= $F8			;no Terminal detected
I2CError = $F5
NO_DEV	= $F4
ID_NFND	= $F3

;I2C adresses
RTC	= $68
24C32	= $57

;CONSTANTS

PB0L	= %11111110	;set PB0 low via AND PBD
PB0H	= %00000001	;set PB0 high via ORA PBD

SELMSK	= $10			;MOTOR ON, DDEN ON
MAXTRK	= 80			;MAX TRACKS

SENSE_OK = $F0			;result byte from SCSI2SD

T_200MS	 = $C3			;200 MS CONSTANT FOR SYSTEM TIMER

MAXTRY	= 10			;MAX TRIES ON ERROR

;==========================================

	ORG BEGIN

RESET			;RESET entry
BIOS	JMP BOOT
	RTS		;JMP WBOOT
	NOP
	NOP
	JMP CONST
	JMP CONIN
	JMP CONOUT
	JMP LIST
	SEC		;JMP AUXOUT
	RTS
	NOP
	SEC		;JMP AUXIN
	RTS
	NOP
	SEC		;JMP HOME
	RTS
	NOP
	JMP SELDSK
	JMP SETTRK
	JMP SETSEC
	JMP READ
	SEC		;JMP WRITE
	RTS
	NOP
	JMP LISTST
	LDA #VERSION	;JMP GET_VERSION
	RTS
	JMP MONITOR
	JMP SET_TIMER1		; 11
	JMP GET_TIMER1		; 12
	JMP SET_TIMER2		; 13
	JMP GET_TIMER2		; 14
	JMP I2CCLR		; 15
	JMP I2CSTOP		; 16
	JMP I2CPOLL		; 17
	JMP I2CADEV		; 18
	JMP I2CR16		; 19
	JMP I2CRDEV		; 1A
	JMP I2CWByte		; 1B
	JMP I2CRByte		; 1C
	JMP I2CRLB		; 1D
	SEC			; xx I2CLOADID
	RTS
	NOP
	JMP I2CGTime		; 1F
	JMP I2CGDate		; 20


;--- DRIVE TABLE ---

DRVTAB	DB $01,$02,$04,$08		;DRIVE TABLE A - D

;==================================

BOOT	SEI
	LDX #$FF		;RESET STACK
	TXS
	LDY #7			;TRY TO BOOT FROM DISC
BOOT1	LDA VEC_TAB,Y		;SET VECTORS
	STA UIRQV,Y
	DEY
	BPL BOOT1
	LDA #0
	LDY #UIRQV-1-I2CDEV	;RESET VARIABLES
BOOT3	STA I2CDEV,Y
	DEY
	BPL BOOT3
	CLD
	LDA #T_200MS		;200 ms
	STA TI1024K		;START SYSTEM TIMER
	JSR INIT_COM		;INITIALIZE SERIAL I/O
	BCS BOOTX1		;if there is no Terminal go for Monitor
	LDY #BOOTM-BOOTM
	JSR PRTSTR		;PRINT ROM MESSAGE
	CLI			;SEARCH FOR BOOT DRIVE
	LDA #0
	STA DRIVE
BOOT1b	LDY DRIVE
	CPY #4			;Drive A - D?
	BCS BOOT1a
	LDA DRVTAB,Y		;GET DRIVE BIT
	ORA #SELMSK		;CHECK FOR DRIVE
	JSR TSTDRV
	BCC BOOTC		;If Drive responds, then BOOT from it
	INC DRIVE
	JMP BOOT1b
				;Check for Drive E: as SCSI
BOOT1a	LDA #10/2		;wait 1s
	STA TIMER0
BOOT2	LDA TIMER0
	BNE BOOT2
	JSR SCSI_RES
	JSR S_SENSE
	BCS BOOT5
	LDA COMBUF
	CMP #SENSE_OK		;if ok then boot from SCSI
	BEQ BOOTC
BOOT5	LDA #20/2		;wait another 2s
	STA TIMER0
BOOT4	LDA TIMER0
	BNE BOOT4
	JSR SCSI_RES		;and try again
	JSR S_SENSE
	BCS BOOTX
	LDA COMBUF
	CMP #SENSE_OK		;if ok then boot from SCSI
	BEQ BOOTC
	BNE BOOTX

BOOTC	LDA #TPA		;BOOT here
	STA DMA			;DMA = TPA
	LDA #TPA/256
	STA DMA+1
	JSR READ		;READ BOOT SECTOR
	BCS BOOTX
	JMP TPA			;BOOT CP/M-65

BOOTX	LDY #ERRM-BOOTM		;PRINT BOOT ERROR
	JSR PRTSTR
BOOTX1	JSR MONITOR		;MONITOR BREAK ENTRY
	JMP BOOT


CONST	LDA CHARBUF		;0 IF NO KEY
	RTS			;^C IF BREAK KEY DEPRESSED


;-------  TERMINAL I/O-ROUTINES 1200 - 38400 Baud  -------

CONIN	STY YBUF	;CHR input; CHR in A, 8 bit transparent
	LDA CHARBUF	;CTRL-C pressed?
	BNE CHRIN2
CHRIN3	BIT PAD		;GET CHR FROM CON to CHR, destroys Y
	BMI CHRIN3	;WAIT FOR START BIT on PB7
	SEI		;NO IRQ FROM HERE!
	LDY #8		;SET FOR 8 BITS
	BIT SPEED	;DELAY 8 us
	BPL CHRINV	;38400 BAUD?
CHRIN1	PHA		;DELAY 11 us 38400 Baud
	PLA
	NOP
	NOP
	LDA PAD		;GET ONE BIT
	ASL A		;shift BIT in C
	ROR CHARBUF	;ROTATE BIT INTO CHR
	DEY
	BNE CHRIN1
CHRIN6	LDA CHARBUF	;CHR received, stopbit ignored
	BNE CHRIN2
	LDA #BREAKC	;if BREAK key pressed
CHRIN2	LDY #0
	STY CHARBUF
CHRINX	LDY YBUF
	CLI
	RTS

CHRINV	BVC CHRIV0
	NOP		; 10 us for 19200 Baud
	LDA (0,X)
	SEC
	BCS CHRIV1
CHRIV0	JSR DELHBT	;delay 1/2 bit
CHRIV1	JSR DELBIT	;DELAY 1 bit
	PHA		;+ 9 us
	PLA
	NOP
	LDA PAD		;GET ONE BIT
	ASL A		;shift BIT in C
	ROR CHARBUF	;ROTATE BIT INTO CHR
	DEY
	BNE CHRIV1
	JSR DELBIT
	JMP CHRIN6	;CHR received & exit


CONOUT	STY YBUF	;PRINTS CHR in A TO CON, destroys Y
	STA CHR		;8 bit transparent
	LDA PBD
	ORA #PB0H	;PB0 = 1
	STA PBD
	SEI		;no IRQ from here
	BIT SPEED
	BPL CHROUTV	;alt speed
	AND #PB0L	;START BIT
	STA PBD
	LDY #8		;SEND 8 BITS
CHROUT1	LSR CHR		;SHIFT OUT 1 BIT
	LDA PBD
	BCS CHROUT3	;symmetric timing
	AND #PB0L	;'0
	BCC CHROUT2
CHROUT3	ORA #PB0H	;'1
	BCC CHROUT2
CHROUT2	STA PBD
	NOP
	DEY
	BNE CHROUT1
	BEQ CHROV4
	
CHROUTV	AND #PB0L	;START BIT
	STA PBD
	LDY #8		;SEND 8 BITS
CHROV1	JSR DELBIT
	LSR CHR		;SHIFT OUT 1 BIT
	LDA PBD
	BCS CHROV3	;symmetric timing
	AND #PB0L	;'0
	BCC CHROV2
CHROV3	ORA #PB0H	;'1
	BCC CHROV2
CHROV2	STA PBD
	DEY
	BNE CHROV1
	JSR DELBIT	
CHROV4	LDA PBD		;SEND 1 STOP BIT
	ORA #PB0H	;NO PARITY
	STA PBD
	JSR DELBIT
	CLI
	BIT PAD			;CHECK FOR BREAK KEY
	BMI CHROV5
BRKTST	BIT PAD			;BREAK KEY STILL DEPRESSED?
	BPL BRKTST
	LDA #BREAKC		;^C TO CHARACTER BUFFER
	STA CHARBUF
CHROV5	LDY YBUF
	RTS


LIST	STA DRA	 	;PRINT CHR TO LST:
	LDA #%00000010
LIST1	BIT IFR
	BEQ LIST1
	RTS


SELDSK	CMP #4			;TEST FOR DRIVE A - D
	BCS SELDS1
	STA DRIVE		;SELECT DISK LOGICAL
	CLC
SELDS1	RTS


SETTRK	LSR A			;SET TRACK LOGICAL
	STA TRACK
	LDA #0
	ROL A
	ROL A
	STA SIDEMS
	RTS


SETSEC	STA SECTOR		;SET SECTOR LOGICAL
	CLC
	RTS


READ	LDA DRIVE		;READ SECTOR TO DMA
	CMP #4
	BCS SCSI_RD
	JSR DRVSEL
READ0	JSR SEEKTR		;SELECT DRIVE AND SET TRACK
	BCS READX
	LDA SECTOR		;SET SECTOR
	STA FDSRG
	LDA #RDSECC
	ORA SIDEMS		;SET SIDE BIT
	SEI
	STA FDSCR		;READ SECTOR
	JSR DELAY
	LDY #0
READ1	BIT FLSTAT		;GET STATUS
	BMI READ2		;DONE
	BVC READ1		;NO DATA
	LDA FDDAR		;GET BYTE
	STA (DMA),Y
	INY
	JMP READ1

READ2	JSR DELAY
	CLI
	LDA FDSCR
	AND #%11011111		;MASK ERROR
	BNE READ3
	STA RETRY		;RESET RETRY COUNTER
	CLC
READX	RTS

READ3	JSR ERROR
	BCC READ0		;REREAD
	RTS


SCSI_RD	JSR SETBLK		;SET BLK NR IN COMBUF
	JSR CHKBLK		;CHECK IF BLOCK VALID
	BCC SCSIRD1
	JSR S_READ
	BCS SCSIRDX
SCSIRD1	LDA SECTOR
	LSR A
	LDY #0
	BCS SCSIRD3
SCSIRD2	LDA SCSIBUF,Y
	STA (DMA),Y
	INY
	BNE SCSIRD2
	CLC
	RTS

SCSIRD3	LDA SCSIBUF+256,Y
	STA (DMA),Y
	INY
	BNE SCSIRD3
	CLC
SCSIRDX	RTS


LISTST	LDA #$FF
	TAX
	STA DRA	 		;PRINT DUMMY
	LDA #%00000010
LISTS2	DEX
	BEQ LISTS1
	BIT IFR	 		;TEST ACK
	BEQ LISTS2
	CLC
	RTS

LISTS1	TXA			;PRINTER NOT READY
	SEC
	RTS


SET_TIMER1			;SET USER TIMER1

	STA TIMER1
	RTS


GET_TIMER1			;GET TIMER1 BYTE 200 ms

	LDA TIMER1
	RTS


SET_TIMER2			;SET USER TIMER2 200 ms

	TAX			;X IS A POINTER TO A PAGE 0 VECTOR
	LDA 0,X
	STA TIMER2
	INX
	LDA 0,X
	STA TIMER2+1
	RTS


GET_TIMER2			;GET STATUS OF TIMER2

	LDA TIMER2+1		;Z=0 TIMEOUT
	BNE G_TIM2
	LDA TIMER2
G_TIM2	RTS


;--------- I2C Commands ------------------------------

I2CCLR	JSR I2CStop	;clear I2C-Bus
	JSR I2CStart
	JSR DUP
	LDX #9		;dummy read 9 bits
CLR1	JSR CLK
	DEX
	BNE CLR1
	JSR I2CStart
	JMP I2CStop


I2CADEV	ASL A		;send 7 bit dev adr to write
	JSR I2CWAIT	;set for write
	BCS ADEVX
	TAY
	JSR I2CSTART
	TYA
	JSR I2CWByte
	BCS ADEVY
ADEVX	RTS

ADEVY	LDA #I2CError
	RTS


I2CR16	TAY		;send word L/H in ZP,A to dev
	LDA $00,Y
	PHA
	INY
	LDA $00,Y
	JSR I2CWByte	;send high byte
	PLA
	BCS R16X	;send low byte
	JSR I2CWByte
R16X	RTS


I2CRDEV			;send 7 bit dev adr to read
	SEC
	ROL A		;set for read
	TAY
	JSR I2CSTART
	TYA
	JSR I2CWByte
	RTS

I2CWByte		;write byte in A to dev
	TAY		;Y to save A
	JSR DDN
	JSR CLKDN
	LDX #8		;send 8 bit
WByte2	JSR DUP
	TYA
	ASL A		;bit in C
	TAY
	BCS WByte1
	JSR DDN		;if C=0
WBYTE1	JSR CLK
	DEX
	BNE WByte2
	JMP IS_ACK

I2CRBYTE		;read byte from dev
	JSR I2CRB	;read 1 byte
	JSR I2CACK
	TYA
	CLC		;Byte in A
	RTS

I2CRLB			;read last byte from dev
	JSR I2CRB	;read 1 byte
	JSR I2CNAK	;send NAK to terminate
	JSR I2CSTOP	
	TYA
	CLC		;Byte in A
	RTS


I2CGTIME		;get time to p.00 cells
	STA ID+1
	LDA #2		;sec, min, hour
	STA ID
	JMP I2CGTD

I2CGDATE		;get date to p.00 cells
	STA ID+1
	LDA #3		;day, dd, mm, yy
	STA ID

I2CGTD	LDA #RTC	;X pointer, ID nr of bytes-1
	JSR I2CADEV
	BCS I2CGTX
	LDA #0		;reg = 0 (time)
	LDX ID
	CPX #3
	BNE I2CGT3
	TXA		;reg = 3	
I2CGT3	JSR I2CWByte
	BCS I2CGTX
	LDA #RTC	;read command
	JSR I2CRDEV
	BCS I2CGTX
I2CGT1	JSR I2CRBYTE
	BCS I2CGTX
	LDX ID+1
	STA 0,X
	INC ID+1
	DEC ID
	BNE I2CGT1
	JSR I2CRLB
	LDX ID+1
	STA 0,X
I2CGTX	RTS

; I2C subroutines

I2CRB	LDY #0		; Y=0 to save byte
	JSR DUP
	LDX #8		;read 8 Bit
RByte1	JSR CLKUP	;SCL = 1
	LDA PBD		;read 1 bit in C
	ASL A
	ASL A		;now bit 6 is in C
	TYA
	ROL A
	TAY
	DEC PAD		;SCL = 0
	DEX
	BNE RBYTE1
	RTS		;byte in Y

I2CPOLL ASL A		;add W bit
I2CWAIT	PHA		;poll dev in A
	LDA #1		;timeout 200 ms
	STA TIMER1
	JSR I2CStart
I2CWT2	PLA
	PHA
	JSR I2CWByte
	BCC I2CWT1
	LDA TIMER1
	BNE I2CWT2
	
I2C_BRK	PLA
	LDA #NO_DEV
	SEC
	RTS

I2CWT1	PLA
	CLC
	RTS

; basic I2C states

I2CStart		;I2C start condition
	JSR DUP
	JSR CLKUP
	JSR DDN
	JSR CLKDN
	RTS

I2CStop			; I2C stop condition
	JSR DDN
	JSR CLKUP
	JSR DUP
	CLC
	RTS

I2CACK	JSR DDN		; Master sends ACK
	JSR CLK
	JSR DUP		; release SDA
	RTS

I2CNAK	JSR DUP		; Master sends NAK
	JSR CLK
	RTS

IS_ACK	JSR DUP		;Check for ACK from dev
	JSR CLKUP
	JSR DIN		;ACK bit in C
	JSR CLKDN
	RTS		; C=0 is ACK

; Bit I/O for I2C  PB6 = SDA, PA0 = SCL

DUP	LDA PBDD	;SDA = 1
	AND #%10111111	;PB6 is Input
	STA PBDD
	RTS

DDN	LDA PBD		;SDA = 0
	AND #%10111111	; PB6 = 0
	STA PBD
	LDA PBDD
	ORA #%01000000	; PB6 is Output
	STA PBDD
	RTS

DIN	LDA PBD		; read 1 bit in C
	ASL A
	ASL A		; now bit 6 is in C
	RTS

CLK	LDA PAD		; SCL = 1
	ORA #%00000001	; PA0 is Output
	STA PAD
	DEC PAD		; SCL = 0
	RTS

CLKUP	LDA PAD		; SCL = 1
	ORA #%00000001	; PA0 is Output
	STA PAD
	RTS

CLKDN	LDA PAD		; SCL = 0
	AND #%11111110
	STA PAD
	RTS


;------ INTERUPT ROUTINES ------

IRQ	STA ABUF		;IRQ HANDLER
	PLA			;GET STATUS REGISTER
	PHA
	AND #%00010000		;BREAK?
	BNE IRQ1
	BIT RIOFLAG		;TIMER IRQ?
	BMI TIMER
	LDA ABUF
	JMP (UIRQV)		;JUMP TO USER IRQ ROUTINE

IRQ1	LDA ABUF
	JMP (BREAKV)		;JUMP TO USER BREAK ROUTINE

TIMER	LDA TIMER0		;TIMER 0 IS SYSTEM TIMER
	BEQ TIM1
	DEC TIMER0
	BNE TIM1
	LDA #0			;DESELECT DRIVE
	STA FDSEL		;MOTOR OFF
TIM1	LDA TIMER1
	BEQ TIM2
	DEC TIMER1		;TIMER 1
TIM2	LDA TIMER2+1
	BEQ TIM3		;TIMER 2
	LDA TIMER2
	BNE TIM4
	DEC TIMER2+1
TIM4	DEC TIMER2
TIM5	LDA #T_200MS		;200 ms
	STA TI1024K		;TIMER RESTART
	BIT PAD			;CHECK FOR BREAK KEY
	BPL IRQBRK
TIM6	LDA ABUF
	RTI

TIM3	LDA TIMER2
	BNE TIM4
	BEQ TIM5

IRQBRK	BIT PAD			;BREAK KEY STILL DEPRESSED?
	BPL IRQBRK
	LDA #BREAKC		;^C TO CHARACTER BUFFER
	STA CHARBUF
	BNE TIM6


UIRQ	RTI			;USER IRQ DUMMY ROUTINE

NMI	JMP (NMIV)		;DEFAULT MON_NMI


;------ HEX MONITOR -------

;HEXMON - Monitor fuer HEX-Tastatur und -Display
;	  des Junior Computers

;=====================================

MON_BRK			;HEX MONITOR BRK ROUTINE

MON_NMI	PHA		;HEX MONITOR NMI ROUTINE
	TXA
	PHA
	TYA
	PHA
	JSR MONITOR
	PLA
	TAY
	PLA
	TAX
	PLA
	RTI


MONITOR	LDA PBDD
	ORA #%00011110	;PB1..4 IS OUTPUT
	STA PBDD
	LDA #1
	STA MODE	;SET ADRESS MODE

START	CLD
STARTA	JSR SCAND	;SCAN DISPLAY
	BNE STARTA	;WAIT UNTIL KEY RELEASED
STARA	JSR SCAND	;DEBOUNCE
	BEQ STARA
	JSR SCAND
	BEQ STARA
	JSR GETKEY	;GET KEY DEPRESSED

;---  COMMAND LOOP  ---

GOEXEC	CMP #$13	;GO KEY?
	BNE ADMODE
	LDX #$FF
	TXS
	JMP (POINT)	;START WITH ADDRESS DISPLAYED

ADMODE	CMP #$10	;AD KEY?
	BNE DAMODE
	LDA #1
	STA MODE	;SET ADDRESS MODE
	BNE STARTA

DAMODE	CMP #$11	;DA KEY?
	BNE STEP
	LDA #0
	STA MODE	;SET DATA MODE
	BEQ STARTA

STEP	CMP #$12	;+ KEY?
	BNE PCKEY
	INC POINT	;POINT=POINT+1
	BNE STEPA
	INC POINT+1
STEPA	JMP START

PCKEY	CMP #$14	;PC KEY?
	BNE ILLKEY
	JSR INIT_COM
	RTS

ILLKEY	CMP #$15	;ILLEGAL KEY
	BPL STARTA

DATA	STA KEY
	LDY MODE
	BNE ADDRES	;IF ADDRESS MODE
	LDA (POINT),Y
	ASL A
	ASL A
	ASL A
	ASL A
	ORA KEY		;SHIFT IN KEY AS LOWER NIBBLE
	STA (POINT),Y
	JMP STARTA

ADDRES	LDX #4		;DO 4 SHIFTS
ADLOOP	ASL POINT
	ROL POINT+1
	DEX
	BNE ADLOOP
	LDA POINT
	ORA KEY
	STA POINT
	JMP STARTA


SCAND	LDA #%01111111	;PA0..PA6 IS OUTPUT
	STA PADD
	LDX #%00001000	;ENABLE DISPLAY
SCDSA	LDA POINT+1	;SHOW ADDRESS
	JSR SHOW
	LDA POINT
	JSR SHOW
	LDY #0		;SHOW MEMORY CELL
	LDA (POINT),Y
	JSR SHOW
SCDSB	LDA #%00000000	;PA0..PA7 IS INPUT
	STA PADD
AK	LDY #3		;SCAN 3 DISPLAY ROWS
	LDX #0		;ROW COUNTER =0
ONEKEY	LDA #$FF
AKA	STX PBD		;OUTPUT ROW NUMBER
	INX
	INX		;SET FOR NEXT ROW
	AND PAD		;INPUT ROW PATTERN
	DEY
	BNE AKA
	LDY #6		;TURN DISPLAY OFF
	STY PBD
	ORA #$80
	EOR #$FF	;INVERT PATTERN
	RTS


SHOW	PHA		;DISPLAY ACCU ON LED
	LSR A
	LSR A
	LSR A
	LSR A
	JSR CONVD	;DISPLAY HIGH NIBBLE
	PLA
	AND #%00001111
	JSR CONVD	;DISPLAY LOW NIBBLE
	RTS


CONVD	TAY		;DISPLAYS ACCU IN 7 SEGMENT
	LDA LOOK,Y
	STA PAD		;OUTPUT SEGMENT PATTERN
	SEI		;NO IRQ FROM HERE
	STX PBD		;ENABLE DISPLAY
	LDY #$FF
CONVD1	DEY		;1.2 MS DELAY
	BNE CONVD1
	DEY		;Y=$FF
	STY PBD		;TURN THE DISPLAY OFF
	CLI		;END OF CRITICAL PHASE
	INX		;SET FOR NEXT DISPLAY
	INX
	RTS


GETKEY	LDX #$21	;START AT ROW 0
GETKEA	LDY #1		;GET ONE ROW
	JSR ONEKEY
	BNE KEYIN
	CPX #$27
	BNE GETKEA
	LDA #$15	;ILLEGAL KEY
	RTS

KEYIN	LDY #$FF	;TRANSLATE PATTERN TO BINARY
KEYINA	ASL A
	BCS KEYINB
	INY
	BPL KEYINA

KEYINB	TXA
	AND #$0F
	LSR A
	TAX
	TYA
	BPL KEYIND

KEYINC	CLC
	ADC #7		;ADD ROW DISPLACEMENT

KEYIND	DEX
	BNE KEYINC
	RTS


;====== SUBROUTINES =======

INIT_COM		;REINITIALIZE SERIAL I/O

	LDA #%01100111
	STA PBD
	LDA #0
	STA PAD
	LDA #$7F
	STA PADD
	LDA #$1F
	STA PBDD
	JMP COMSENSE


TSTDRV	STA FDSEL	;TEST IF DRIVE IS PRESENT
	LDA #10/2	;1 SEC WAIT
	STA TIMER0
TSTDRV1	BIT FDSCR	;TEST BUSY BIT
	BPL TSTDRV2
	LDA TIMER0
	BNE TSTDRV1	;TRY UNTIL TIMEOUT
	SEC		;DRIVE NOT READY OR NOT THERE
	RTS

TSTDRV2	CLC		;DRIVE READY
	RTS


PRTSTR	LDA BOOTM,Y	;PRINT MESSAGE
	BEQ PRTSTRX
	JSR CONOUT
	INY
	BNE PRTSTR
PRTSTRX	RTS


DRVSEL	LDY DRIVE		;SELECT DRIVE
	LDA DRVTAB,Y		;GET DRIVE BIT
	ORA #SELMSK
	STA FDSEL		;MOTOR ON
DRVSE1	BIT FDSCR		;GET STATUS
	BMI DRVSE1		;WAIT FOR READY
	LDA #50/2		;5 SECONDS MOTOR ON
	STA TIMER0
	RTS


SEEKTR	JSR READY		;SEEK TRACK
	LDA TRACK
	STA FDDAR		;SET TRACK
	LDA #SEEKC
	STA FDSCR		;SEEK
SEEK1	JSR READY
	AND #%10011001		;MASK SEEK ERROR
	BNE SKERR1
	CLC
SERR	RTS

SKERR1	JSR ERROR		;CHECK ERROR COUNT
	BCC SEEKTR
	RTS


ERROR	INC RETRY		;INC RETRY COUNTERS
RESTORE	SEI			;RECALIBRATE
	LDA #RSTORC
	STA FDSCR		;RESTORE
	CLI
	LDA RETRY		;NO MORE TRIES?
	CMP #MAXTRY		;C=1 ERROR
	RTS


DELAY	JSR DELAY1		;DELAY 28 uS
DELAY1	NOP
	RTS


READY	JSR DELAY		;WAITS WHILE CONTROLLER
	LDA #%10000001		;IS BUSY AND DRIVE NOT READY
READY1	BIT FDSCR
	BNE READY1
	LDA FDSCR
	RTS

;-------  SCSI Routines  ---------------

S_READ	LDA #RD_COM		;SCSI READ
	STA COMBUF
	JSR S_COM		;DO SELECT AND EXEC COMMAND
	BCS S_READX
	LDA #%01101111
	JSR S_WAIT
	BCS S_READX
	LDY #0			;READ 512 BYTES
S_READ2	LDA SCSI_D
	STA SCSIBUF,Y
	INY
	BNE S_READ2
S_READ3	LDA SCSI_D
	STA SCSIBUF+256,Y
	INY
	BNE S_READ3
	JSR GET_SM		;GET SCSI STATUS
	BCS S_READX
	JSR S_UPD		;UPDATE BLK/FLAG INFO
S_READX	RTS

SCSI_RES LDA #10/2		;SET TIMEOUT TO 1 s
	STA TIMER0
	LDA #%00100110		;Wait for SCSI Bus to be ready
	JSR S_WAIT
	BCS S_RESX

SCSI_RST			;do a SCSI bus reset
	LDA #1
	STA SCSI_F		;MARK SCSI BUFFER AS INVALID
	LDA #$80		;INITIALIZE SCSI DRIVE
	STA SCSI_R
	LDX #0
S_RES1	DEX
	BNE S_RES1
	TXA			;reset pulse
	STA SCSI_R
S_RES2	DEX
	BNE S_RES2
	CLC			;all clear, no check!
S_RESX	RTS

S_SENSE	LDX #5
S_SEN3	LDA C_SENSE,X		;set COMBUF to SENSE command
	STA COMBUF,X
	DEX
	BPL S_SEN3
	JSR S_COM		;do SENSE
	BCS S_SENX
	JSR GETBYT		;Get STATUS
	BCS S_SENX
	STA COMBUF		;Save Result 
	LDY #$15		;get another $15 status bytes
S_SEN5	JSR GETBYT		;and forget them
	BCS S_SENX
	DEY
	BNE S_SEN5
	JSR GET_SM
S_SENX	RTS


S_UPD	LDA COMBUF+2		;UPDATE BLK NR AND SCSI FLAG
	STA SCSI_B+1
	LDA COMBUF+3
	STA SCSI_B
	LDA #0
	STA SCSI_F
	RTS


S_COM	LDA #20/2		;SET TIMEOUT TO 2 s
	STA TIMER0
SCSISE1	LDA #%00100110
	JSR S_WAIT
	BCS S_COMX
	LDA #1			;SELECT DRIVE 1
	STA SCSI_D
	STA SCSI_SE
	LDY #0
S_COM1	LDA #%11101110
	JSR S_WAIT
	BCS S_COMX
	LDA COMBUF,Y
	STA SCSI_D
	INY
	CPY #6
	BCC S_COM1
	CLC
S_COMX	RTS


GET_SM	LDA #%11101111		;GET STATUS AND MESSAGE
	JSR S_WAIT
	BCS GET_SMX
	LDY SCSI_D
	LDA #%11111111
	JSR S_WAIT
	BCS GET_SMX
	LDA SCSI_D
	BNE GET_SM1
	TYA
	BNE GET_SM1
	CLC
GET_SMX	RTS

GET_SM1	SEC		;reset SCSI bus
	RTS


GETBYT	LDA #%01101111		;get byte from SCSI
	JSR S_WAIT
	BCS GETBYTX
	LDA SCSI_D
GETBYTX	RTS


S_WAIT	LDX TIMER0
	BEQ S_WAIT1
	CMP SCSI_ST
	BNE S_WAIT
	CLC
	RTS

S_WAIT1	SEC
	RTS
	

SETBLK	LDX #1
	STX COMBUF+4
	DEX
	STX COMBUF+1
	STX COMBUF+5
SETBLK1	LDA TRACK
	ASL A
	ASL A
	ORA SIDEMS		;ADD SIDE BIT
	ASL A
	ASL A
	ASL A
	ASL A
	ASL A
	ORA SECTOR		;ADD SECTOR BITS
	ROR A
	STA COMBUF+3
	LDA TRACK
	LSR A
	STA COMBUF+2
	RTS


CHKBLK	LDA COMBUF+3		;CHECK IF BLK IN BUFFER VALID
	CMP SCSI_B
	BNE CHKBL1
	LDA COMBUF+2
	CMP SCSI_B+1
	BNE CHKBL1
	LDA SCSI_F
	LSR A
	RTS

CHKBL1	SEC
	RTS


;--- INTERUPT VECTORS ---

VEC_TAB	DW UIRQ
	DW MON_NMI
	DW MON_BRK
	DW IRQ


;--- MESSAGES ---

BOOTM	DB CR,CLS,'Junior BOOT-ROM '
	DB 'V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30
	DB CR,LF,EOT
ERRM	DB 'BOOT failed ...',EOT

;--- SCSI Commands ---

C_SENSE	DB SENSE_COM,0,0,0,$16,0

;--- COM Time Tables ---

TIM_TAB		DB $01,$04,$07,$0A,$12,$25,$4A
SPEED_TAB	DB $80,$40,$00,$00,$00,$00,$00
BIT_TAB		DB $00,$00,$03,$0A,$20,$4A,$9D
HBT_TAB		DB $00,$00,$00,$04,$0F,$24,$4D

;--- HEX DISPLAY LOOKUP TABLE ---

LOOK	DB $40		;0
	DB $79		;1
	DB $24		;2
	DB $30		;3
	DB $19		;4
	DB $12		;5
	DB $02		;6
	DB $78		;7
	DB $00		;8
	DB $10		;9
	DB $08		;A
	DB $03		;B
	DB $46		;C
	DB $21		;D
	DB $06		;E
	DB $0E		;F

;-------  TERMINAL I/O-ROUTINES  -------

DELBIT	LDA BITTIME	;Set up for Bit Time
	BIT SPEED
	BVC DELBIT1
	LDA (0,X)	; 6 us for 19200 Baud
	RTS

DELHBT	LDA HBTTIME	;SET UP FOR HALF BIT TIME
DELBIT1	SEC
DELBIT2	SBC #1
	BCS DELBIT2
	RTS


COMSENSE			;detect baudrate
	LDX #0
	SEI
COMSEN1	BIT PAD			;wait for start bit
	BMI COMSEN1
COMSEN2	INX			;measure start bit time
	BIT PAD
	BPL COMSEN2
	CLI
	TXA
	LDX #SPEED_TAB-TIM_TAB
COMSEN4	CMP TIM_TAB,X
	BCS COMSEN3
	DEX
	BNE COMSEN4

COMSEN3	LDA SPEED_TAB,X		;set timing for COM
	STA SPEED
	LDA BIT_TAB,X
	STA BITTIME
	LDA HBT_TAB,X
	STA HBTTIME
	CLC
	RTS

COMSERR	LDA #NOTERM
	SEC
	RTS


SPARE	DS $FFFA-SPARE,$FF	;TO PLACE VECTORS CORRECTLY

	DW NMI
	DW RESET
	DW IRQ


EOM	END
