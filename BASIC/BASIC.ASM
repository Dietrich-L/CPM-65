;BASIC.COM  Microsoft compatible 6502 BASIC

;D. Lausberg	(c) 1995
;V1.0	08.04.95
;V1.1	02.09.95	EDIT COMMAND and LINE EDITOR
;V1.2	13.01.96	G_FIX Error corrected
;V1.3	17.01.96	upper case conversion, PI
;V1.4	06.03.96	printer,disk support
;V1.5	12.06.22	BASIC filename implemented
Version = $15

;Parameters
ZERO	= $00		;ZERO PAGE
SRC_CHR	= $03		;SEARCH CHR
HK_F	= $04		;FLAG FOR HOCHKOMMA MODE
INBUFP	= $05		;INPUT BUFFER POINTER
DIMBUF	= $06		;1. CHR OF DIM VARIABLE
VAR_F	= $07		;VARIABLE TYPE FLAG
INT_F	= $08		;INTEGER FLAG
DATA_F	= $09		;DATA FLAG
DIM_F	= $0A		;DIM FLAG
INP_F	= $0B		;INPUT FLAG
SGN_F	= $0C		;SIGN FLAG
OUT_F	= $0D		;OUTPUT FLAG
IO_CHAN	= $0E		;NR OF I/O CHANNEL 0=KEYB 3=SCREEN
BASADR	= $11		;BASIC ADDRESS
DES_PNT	= $13		;POINTER TO NEXT DESCRIPTOR
L_STRP	= $14		;POINTER ON LAST RECENTLY USED STRING
STRTAB	= $16		;STRING DESCRIPTOR TABLE
T_PNT	= $1F		;TRANSFER POINTER
PNT	= $21		;GENERAL PURPOSE POINTER
REG	= $23		;REGISTER FOR FUNCTION ARGUMENTS
BASBEG	= $28		;BEGIN OF BASIC STATEMENTS
VTBEG	= $2A		;POINTER TO BEGIN OF VARIABLES TABLE
ATBEG	= $2C		;POINTER TO BEGIN OF ARRAY TABLE
VTEND	= $2E		;POINTER TO END OF VARIABLES TABLE
STREND	= $30		;POINTER TO END OF STRING AREA
STRBEG	= $32		;POINTER TO BEGIN OF LAST STRING
NXTAD	= $34		;POINTER TO NEXT ADDRESS IN RAM
ALINNR	= $36		;NR OF ACTUAL BASIC LINE
DIRECT_F = $37		;FLAG FOR DIRECT MODE
CONTLN	= $38		;LINE NR FOR CONT COMMAND
NXTBEF	= $3A		;POINTER ON NEXT BASIC COMMAND
ADATA	= $3C		;LINE NR OF ACTUAL DATA
NXTDATA	= $3E		;POINTER ON NEXT DATA
INPPNT	= $40		;INPUT SOURCE POINTER
VNAME	= $42		;NAME OF CURRENT VARABLE
VPNT	= $44		;POINTER ON CURRENT VARABLE
P_FORL	= $46		;POINTER ON FOR/NEXT VARIABLE
AOPER	= $48		;POINTER ON ACTUAL OPERATOR

OPMSK	= $4A		;OPERATOR MASK
DEFPNT	= $4B		;DEF FN POINTER
GCMEM	= $4D		;GARBAGE COLLECTION MEMORY

J_FN	= $51		;JUMP TO BASIC FUNCTION
BUF1	= $54		;BUFFER FOR ARGUMENTS 1
TARGAD	= $55		;LAST TARGET ADDRESS OF MOVE
ENDAD	= $57		;END ADDRESS OF BLOCK TO BE MOVED
BUF2	= $59		;BUFFER FOR ARGUMENTS 2
BEGAD	= $5C		;START ADDRESS OF BLOCK TO BE MOVED
F_ACCU1	= $5E		;FLOATING POINT ARITH ACCU 1

F_ACCU2	= $66		;FLOATING POINT ARITH ACCU 2

ACOMP	= $6C		;ACCU COMPARISON BYTE
ARND	= $6D		;ACCU ROUND BYTE
P_FUNC	= $6E		;POINTER FOR FUNCTION PROCESSING
CHRGTP	= $71		;CHR GET POINTER

RNDNR	= $76		;RANDOM NR
CLOCK	= $7B		;24H CLOCK
STATUS	= $7E		;STATUS VARABLE
CUR_COL	= $7F		;CURSOR COLOUMN

;SYSTEM ADDRESSES

TEMPX	= $D0
TEMPY	= $D1
BUFPNT	= $D2		;Pointer for disk buffer (=DMA)
FLAG_8	= $D3		;Channel #8 Flag
IN_DEV	= $D4		;Input device
OUT_DEV	= $D5		;Output device
DMABUF	= $D6		;original DMA page address
BDOS	= $F0
FCB1	= $F6
FCB2	= $F4
DMA	= $FE

STACK	= $100
TPA	= $200

RDTEN	= $F6DC		;6532 RIOT READ TIMER ENABLE IRQ
TIM1C	= $F404		;6522 VIA TIMER 1 COUNTER
TIM2C	= $F408		;6522 VIA TIMER 2 COUNTER

;ERROR CODES

EOF	= $D7
NOTFND	= $DD

;BDOS COMMANDS

CONIN	= $1
CONOUT	= $2
LISTDEV	= $5
CONIO	= $6
STROUT	= $9
CONST	= $B
SELDRV	= $E
DOPEN	= $F
DCLOSE	= $10
ERASE	= $13
RDSEQ	= $14
WRITE	= $15
CREATE	= $16
GETDRV	= $19
BIOSC	= $1A

;BIOS COMMANDS

_CHRIN	= 3
_SETTRK	= 10
_SETSEC = 11
_WRITE	= 13

;CONTROL CHARACTERS

EOT	= $00
CTRLA	= $01		;Control A
BRK_KEY	= $03
CTRLD	= $04		;Control D
CTRLF	= $06		;Control F
BS	= $08
HT	= $09
LF	= $0A
CLS	= $0C
CR	= $0D
SI	= $0F
CTRLS	= $13		;Control S
GS	= $1D
SP	= $20
HK	= $22
RUBOUT	= $7F

;SPECIAL CODES

BIT_Z	= $24			;BIT Z OPCODE TO MASK 1 BYTE INSTRUCTION
BIT_ABS	= $2C			;BIT OPCODE TO MASK 2 BYTE INSTRUCTION
PRINT_TOK = $99			;PRINT TOKEN

;--------------------------------------------------------

	ORG TPA

INBUF			;BASIC INPUT BUFFER
	LDA #0		;BASIC INITIALIZATION ROUTINE
	LDX #BDOS-1	;will be overwritten after startup
INIT1	STA ZERO,X	;CLEAR PAGE 0
	DEX
	BNE INIT1
	CLD
	LDY #Z_TABX-Z_TAB-1
INIT2	LDA Z_TAB,Y
	DEY
	LDX Z_TAB,Y
	STA ZERO,X
	DEY
	BPL INIT2
	LDA DMA		;save original DMA vector
	STA DMABUF
	LDA DMA+1
	STA DMABUF+1
	LDA BDOS+1	;SET END OF BASIC'S RAM
	STA STREND
	STA NXTAD
	LDA BDOS+2
	STA STREND+1
	STA NXTAD+1
	INY		;Y=$00
	TYA		;CLEAR WORKSPACE
	STA (BASBEG),Y
	INC BASBEG
	LDA BASBEG
	LDY BASBEG+1
	JSR GARBCOL
	LDA #INITM	;PRINT 'JUNIOR BASIC Vx.x'
	LDY #INITM/256
	JSR PRT_STR
	SEC		;CALCULATE WORKSPACE SIZE
	LDA NXTAD
	SBC BASBEG
	TAX
	LDA NXTAD+1
	SBC BASBEG+1
	JSR PRT_16	;AND PRINT IT
	LDA #BYTFRE	;PRINT 'BYTES FREE'
	LDY #BYTFRE/256
	JSR PRT_STR
	JSR COLD
	LDA #$01	;PRESET STACKTOP
	STA STACK+$FC
	STA STACK+$FD
	LDY #1
	LDA #SP
	CMP (FCB1),Y
	BEQ INIT3	;check for filename to execute
	JSR SETFCB4
	JSR LOAD_IMM	;load BASIC file
	JSR BAS_RST
	JSR L_INS	;BASIC RESET AND REBIND LINES
	LDA #'R		;put 'RUN in INBUF
	STA INBUF
	LDA #'U
	STA INBUF+1
	LDA #'N
	STA INBUF+2
	LDX #3
	JSR ST_EOT	;put EOT in INBUF
	JMP MAIN7	;execute RUN command

INIT3	JMP WARM

;---   ZERO PAGE BYTES   ---

Z_TAB	DB GCMEM+3,$03
	DB ZERO,$4C			;JMP OPCODE
	DB ZERO+1,ILLQ_ERR
	DB ZERO+2,ILLQ_ERR/256
	DB J_FN,$4C			;JMP OPCODE
	DB CHRGTP-1,$AD			;LDA ABS OPCODE
	DB CHRGTP+2,$60			;RTS OPCODE
	DB DES_PNT,STRTAB
	DB BASBEG,HEAP
	DB BASBEG+1,HEAP/256
	DB OUT_DEV,3			;Output device is screen
Z_TABX

;---   STARTUP MESSAGES  ---

INITM	DB CLS,'Junior BASIC V'
	DB VERSION/16+$30,'.',VERSION*$1000/$1000+$30,'     ',EOT
BYTFRE	DB ' Bytes free',CR,LF,EOT

;until here approx. 200 bytes input buffer

;---  COMMAND TABLE ---

COM_TAB	DW END-1	;END
	DW FOR-1
	DW NEXT-1
	DW DATA-1
	DW INPUT@-1
	DW INPUT-1
	DW DIM-1
	DW READ-1
	DW LET-1
	DW GOTO-1
	DW RUN-1
	DW IF-1
	DW RESTORE-1
	DW GOSUB-1
	DW RETURN-1
	DW REM-1
	DW STOP-1
	DW ON-1
	DW WAIT-1
	DW LOAD-1
	DW SAVE-1
	DW BYE-1
	DW DEF-1
	DW POKE-1
	DW PRINT@-1
	DW PRINT-1
	DW CONT-1
	DW LIST-1
	DW CLR-1
	DW CMD-1
	DW SYS-1
	DW EDIT-1
	DW KILL-1
	DW GET-1
	DW NEW-1
	DW SGN			;FROM HERE WITHOUT -1
	DW INT
	DW ABS
	DW DUMMY4		;USR NOT IMPLEMENTED
	DW FRE
	DW POS
	DW SQR
	DW RND
	DW LOG
	DW EXP
	DW COS
	DW SIN
	DW TAN
	DW ATN
	DW PEEK
	DW LEN
	DW STR@
	DW VAL
	DW ASC
	DW CHR
	DW LEFT
	DW RIGHT
	DW MID
	DW DUMMY4		;Dummy fn 1
	DW DUMMY4		;Dummy fn 2
	DW DUMMY4		;Dummy fn 3
	DW DUMMY4		;Dummy fn 4
	DW DUMMY4		;Dummy fn 5
	DW DUMMY4		;Dummy fn 6
	DW DUMMY4		;Dummy fn 7
	DW DUMMY4		;Dummy fn 8
	DW DUMMY4		;Dummy fn 9
	DW DUMMY4		;Dummy fn 10
	DW DUMMY4		;Dummy fn 11
	DW DUMMY4		;Dummy fn 12
	DW DUMMY4		;Dummy fn 13
	DW DUMMY4		;Dummy fn 14
	DW DUMMY4		;Dummy fn 15
	DW OPEN-1
	DW CLOSE-1

;--- MATH OPERATORS HIRARCHY AND EXECUTION VECTORS ---
 
OP_TAB	DB $79
	DW PLUS-1
	DB $79
	DW MINUS-1
	DB $7B
	DW MUL-1
	DB $7B
	DW DIV-1
	DB $7F
	DW EXPO-1
	DB $50
	DW AND-1
	DB $46
	DW OR-1
	DB $7D
	DW NEG-1
	DB $5A
	DW NOT-1
	DB $64
	DW COMP-1


;---  BASIC COMMAND WORDS  ---

BAS_BEF	DB 'EN','D'+$80
	DB 'FO','R'+$80
	DB 'NEX','T'+$80
	DB 'DAT','A'+$80
	DB 'INPUT','#'+$80
	DB 'INPU','T'+$80
	DB 'DI','M'+$80
	DB 'REA','D'+$80
	DB 'LE','T'+$80
	DB 'GOT','O'+$80
	DB 'RU','N'+$80
	DB 'I','F'+$80
	DB 'RESTOR','E'+$80
	DB 'GOSU','B'+$80
	DB 'RETUR','N'+$80
	DB 'RE','M'+$80
	DB 'STO','P'+$80
	DB 'O','N'+$80
	DB 'WAI','T'+$80
	DB 'LOA','D'+$80
	DB 'SAV','E'+$80
	DB 'BY','E'+$80
	DB 'DE','F'+$80
	DB 'POK','E'+$80
	DB 'PRINT','#'+$80
	DB 'PRIN','T'+$80
	DB 'CON','T'+$80
	DB 'LIS','T'+$80
	DB 'CL','R'+$80
	DB 'CM','D'+$80
	DB 'SY','S'+$80
	DB 'EDI','T'+$80
	DB 'KIL','L'+$80
	DB 'GE','T'+$80
	DB 'NE','W'+$80
	DB 'TAB','('+$80
	DB 'T','O'+$80
	DB 'F','N'+$80
	DB 'SPC','('+$80
	DB 'THE','N'+$80
	DB 'NO','T'+$80
	DB 'STE','P'+$80
	DB '+'+$80
	DB '-'+$80
	DB '*'+$80
	DB '/'+$80
	DB '^'+$80
	DB 'AN','D'+$80
	DB 'O','R'+$80
	DB '>'+$80
	DB '='+$80
	DB '<'+$80
	DB 'SG','N'+$80
	DB 'IN','T'+$80
	DB 'AB','S'+$80
	DB 'US','R'+$80
	DB 'FR','E'+$80
	DB 'PO','S'+$80
	DB 'SQ','R'+$80
	DB 'RN','D'+$80
	DB 'LO','G'+$80
	DB 'EX','P'+$80
	DB 'CO','S'+$80
	DB 'SI','N'+$80
	DB 'TA','N'+$80
	DB 'AT','N'+$80
	DB 'PEE','K'+$80
	DB 'LE','N'+$80
	DB 'STR','$'+$80
	DB 'VA','L'+$80
	DB 'AS','C'+$80
	DB 'CHR','$'+$80
	DB 'LEFT','$'+$80
	DB 'RIGHT','$'+$80
	DB 'MID','$'+$80
	DB 'US','R'+$80		;Dummy fn 1
	DB 'US','R'+$80		;Dummy fn 2
	DB 'US','R'+$80		;Dummy fn 3
	DB 'US','R'+$80		;Dummy fn 4
	DB 'US','R'+$80		;Dummy fn 5
	DB 'US','R'+$80		;Dummy fn 6
	DB 'US','R'+$80		;Dummy fn 7
	DB 'US','R'+$80		;Dummy fn 8
	DB 'US','R'+$80		;Dummy fn 9
	DB 'US','R'+$80		;Dummy fn 10
	DB 'US','R'+$80		;Dummy fn 11
	DB 'US','R'+$80		;Dummy fn 12
	DB 'US','R'+$80		;Dummy fn 13
	DB 'US','R'+$80		;Dummy fn 14
	DB 'US','R'+$80		;Dummy fn 15
	DB 'OPE','N'+$80
	DB 'CLOS','E'+$80

	DB EOT


;---  ERROR TABLE  ----

ERR_TAB	DB 'NEXT WITHOUT FO','R'+$80
ERR1	DB 'SYNTA','X'+$80
ERR2	DB 'RETURN WITHOUT GOSU','B'+$80
ERR3	DB 'OUT OF DAT','A'+$80
ERR4	DB 'ILLEGAL QUANTIT','Y'+$80
ERR5	DB 'OVERFLO','W'+$80
ERR6	DB 'OUT OF MEMOR','Y'+$80
ERR7	DB 'UNDEF',$27,'D STATEMEN','T'+$80
ERR8	DB 'BAD SUBSCRIP','T'+$80
ERR9	DB 'REDIM',$27,'D ARRA','Y'+$80
ERR10	DB 'DIVISION BY ZER','O'+$80
ERR11	DB 'ILLEGAL DIREC','T'+$80
ERR12	DB 'TYPE MISMATC','H'+$80
ERR13	DB 'STRING TOO LON','G'+$80
ERR14	DB 'FILE DAT','A'+$80
ERR15	DB 'FORMULA TOO COMPLE','X'+$80
ERR16	DB 'CAN',$27,'T CONTINU','E'+$80
ERR17	DB 'UNDEF',$27,'D FUNCTIO','N'+$80
ERR18	DB 'DIS','K'+$80

;---  MESSAGES  ---

ERRORM	DB ' ERROR',EOT
IN_M	DB ' IN ',EOT
READYM	DB CR,LF,'READY.',CR,LF,EOT
BREAKM	DB CR,LF,'BREAK',EOT
REDOM	DB '?REDO FROM START',CR,LF,EOT
EXTRAM	DB '?EXTRA IGNORED',CR,LF,EOT

;---  LEGAL KEYS FOR FILENAMES  ---

KEYTAB	DB '!#$&+^_'
KEYTX

;---  CONSTANTS  ---

PI	DB $82,$49,$0F,$DA,$A1		;3.14159265
M32768	DB $90,$80,$00,$00,$20		;-32768
F_10	DB $84,$20,$00,$00,$00		;10

F_CONST	DB $81,$00,$00,$00,$00		;FLOATING POINT CONSTANTS FOR
F_LOG3	DB $03,$7F,$5E,$56,$CB		;LOG
	DB $79
	DB $80,$13,$9B,$0B,$64
	DB $80,$76,$38,$93,$16
	DB $82,$38,$AA,$3B,$20
F_LOG1	DB $80,$35,$04,$F3,$34
F_LOG2	DB $81,$35,$04,$F3,$34
F_LOG4	DB $80,$80,$00,$00,$00
F_LOG5	DB $80,$31,$72,$17,$F8

F_STR	DB $9B,$3E,$BC,$1F,$FD		;CONSTANT FOR STRING CONVERSION
F_STR1	DB $9E,$6E,$6B,$27,$FD
F_STR2	DB $9E,$6E,$6B,$28,$00

CON_TAB	DB $80,$00,$00,$00,$00		;O.5
CON_C1	DB $FA,$0A,$1F,$00,$00		;CONVERSION CONSTANTS FOR FLOAT
	DB $98,$96,$80,$FF,$F0		;TO ASCII
	DB $BD,$C0,$00,$01,$86
	DB $A0,$FF,$FF,$D8,$F0
	DB $00,$00,$03,$E8,$FF
	DB $FF,$FF,$9C,$00,$00
	DB $00,$0A,$FF,$FF,$FF
	DB $FF,$FF,$DF,$0A,$80
	DB $00,$03,$4B,$C0,$FF
	DB $FF,$73,$60,$00,$00
	DB $0E,$10,$FF,$FF,$FD
	DB $A8,$00,$00,$00,$3C

F_EXP	DB $81,$38,$AA,$3B,$29		;CONSTANTS FOR EXPONENTIATION
F_EXP1	DB $07,$71,$34,$58,$3E
	DB $56
	DB $74,$16,$7E,$B3,$1B
	DB $77,$2F,$EE,$E3,$85
	DB $7A,$1D,$84,$1C,$2A
	DB $7C,$63,$59,$58,$0A
	DB $7E,$75,$FD,$E7,$C6
	DB $80,$31,$72,$18,$10
	DB $81,$00,$00,$00,$00

F_COS	DB $81,$49,$0F,$DA,$A2
F_SIN	DB $83,$49,$0F,$DA,$A2
F_SIN1	DB $7F,$00,$00,$00,$00
F_SIN2	DB $05
	DB $84,$E6,$1A,$2D,$1B
	DB $86,$28,$07,$FB,$F8
	DB $87,$99,$68,$89,$01
	DB $87,$23,$35,$DF,$E1
	DB $86,$A5,$5D,$E7,$28
	DB $83,$49,$0F,$DA,$A2
	DB $A1,$54,$46,$8F,$13
	DB $8F,$52,$43,$89,$CD

F_ATN	DB $0B
	DB $76,$B3,$83,$BD,$D3
	DB $79,$1E,$F4,$A6,$F5
	DB $7B,$83,$FC,$B0,$10
	DB $7C,$0C,$1F,$67,$CA
	DB $7C,$DE,$53,$CB,$C1
	DB $7D,$14,$64,$70,$4C
	DB $7D,$B7,$EA,$51,$7A
	DB $7D,$63,$30,$88,$7E
	DB $7E,$92,$44,$99,$3A
	DB $7E,$4C,$CC,$91,$C7
	DB $7F,$AA,$AA,$AA,$13
	DB $81,$00,$00,$00,$00

C_RND	DB $98,$35,$44,$7A		;CONSTANTS FOR RND
C_RND1	DB $68,$28,$B1,$46

;----------------------

S_FORL	TSX		;SEARCH FOR LOOP IN STACK
	INX
	INX
	INX
	INX
S_FORL3	LDA STACK+1,X
	CMP #$81
	BNE S_FORLX
	LDA P_FORL+1
	BNE S_FORL1
	LDA STACK+2,X
	STA P_FORL
	LDA STACK+3,X
	STA P_FORL+1
S_FORL1	CMP STACK+3,X
	BNE S_FORL2
	LDA P_FORL
	CMP STACK+2,X
	BEQ S_FORLX
S_FORL2	TXA
	CLC
	ADC #$12
	TAX
	BNE S_FORL3
S_FORLX	RTS


M_ROOM	JSR GARBCOL		;MAKE ROOM FOR PROGRAM
	STA VTEND
	STY VTEND+1

MOVE	SEC			;MOVE MEMORY BLOCK IN BEGAD, ENDAD
	LDA ENDAD		;TO TARGAD
	SBC BEGAD
	STA T_PNT
	TAY
	LDA ENDAD+1
	SBC BEGAD+1
	TAX
	INX
	TYA
	BEQ MOVE1
	LDA ENDAD
	SEC
	SBC T_PNT
	STA ENDAD
	BCS MOVE2
	DEC ENDAD+1
	SEC
MOVE2	LDA TARGAD
	SBC T_PNT
	STA TARGAD
	BCS MOVE3
	DEC TARGAD+1
	BCC MOVE3
MOVE4	LDA (ENDAD),Y
	STA (TARGAD),Y
MOVE3	DEY
	BNE MOVE4
	LDA (ENDAD),Y
	STA (TARGAD),Y
MOVE1	DEC ENDAD+1
	DEC TARGAD+1
	DEX
	BNE MOVE3
	RTS


STK_CHK	ASL A			;STACK CHECK
	ADC #$3E
	BCS OM_ERR
	STA T_PNT
	TSX
	CPX T_PNT
	BCC OM_ERR
	RTS


GARBCOL	CPY STREND+1		;GARBAGE COLLECTION
	BCC GACOLX
	BNE GACOL1
	CMP STREND
	BCC GACOLX
GACOL1	PHA
	LDX #9
	TYA
GACOL2	PHA
	LDA BUF1,X
	DEX
	BPL GACOL2
	JSR RM_STR		;REMOVE STRING
	LDX #$F7
GACOL3	PLA
	STA F_ACCU1,X
	INX
	BMI GACOL3
	PLA
	TAY
	PLA
	CPY STREND+1
	BCC GACOLX
	BNE OM_ERR
	CMP STREND
	BCS OM_ERR
GACOLX	RTS


OM_ERR	LDX #ERR6-ERR_TAB	;OUT OF MEMORY ERROR
ERROR	LSR OUT_F		;ERROR MESSAGES
	LDA IO_CHAN		;CHECK OUTPUT FLAG
	BEQ ERROR1
	JSR RES_IO		;IN_DEV=0, OUT_DEV=3
ERROR1	JSR CRLF		;PRINT CR, LF
	JSR PRT_3F		;PRINT ?
ERROR2	LDA ERR_TAB,X
	PHA
	AND #$7F
	JSR PRT_CHR		;PRINT CHR
	INX
	PLA
	BPL ERROR2
	JSR RESET
	LDA #ERRORM		;PRINT ' ERROR'
	LDY #ERRORM/256
ERROR3	JSR PRT_STR
	LDY DIRECT_F
	INY
	BEQ WARM
	JSR PRT_LNR		;PRINT LINE NR


WARM	LSR OUT_F		;BASIC WARM START
	LDA #READYM
	LDY #READYM/256
	JSR PRT_STR

MAIN	JSR GETLINE		;BASIC MAIN LOOP
MAIN7	STX CHRGTP		;STORE TO CHR GET POINTER
	STY CHRGTP+1
	JSR GETCHR		;GET NEXT CHR
	TAX
	BEQ MAIN
	LDX #$FF
	STX DIRECT_F
	BCC MAIN1
	JSR G_TOKEN		;GET BASIC TOKEN
	JMP EXEC
MAIN1	JSR G_FIX		;GET FIXED DIGIT NR
	JSR G_TOKEN
	STY INBUFP		;INPUT BUFFER POINTER
	JSR G_LINNR		;GET LINE NR
	BCC MAIN2
	LDY #1
	LDA (BEGAD),Y
	STA T_PNT+1
	LDA VTBEG
	STA T_PNT
	LDA BEGAD+1
	STA PNT+1
	LDA BEGAD
	DEY
	SBC (BEGAD),Y
	CLC
	ADC VTBEG
	STA VTBEG
	STA PNT
	LDA VTBEG+1
	ADC #$FF
	STA VTBEG+1
	SBC BEGAD+1
	TAX
	SEC
	LDA BEGAD
	SBC VTBEG
	TAY
	BCS MAIN3
	INX
	DEC PNT+1
MAIN3	CLC
	ADC T_PNT
	BCC MAIN4
	DEC T_PNT+1
	CLC
MAIN4	LDA (T_PNT),Y
	STA (PNT),Y
	INY
	BNE MAIN4
	INC T_PNT+1
	INC PNT+1
	DEX
	BNE MAIN4
MAIN2	JSR BAS_RST		;BASIC RESET
	JSR L_INS
	LDA INBUF
	BEQ MAIN
	CLC
	LDA VTBEG
	STA ENDAD
	ADC INBUFP
	STA TARGAD
	LDY VTBEG+1
	STY ENDAD+1
	BCC MAIN5
	INY
MAIN5	STY TARGAD+1
	JSR M_ROOM
	LDA BASADR
	LDY BASADR+1
	STA STACK+$FE
	STY STACK+$FF
	LDA VTEND
	LDY VTEND+1
	STA VTBEG
	STY VTBEG+1
	LDY INBUFP
	DEY
MAIN6	LDA STACK+$FC,Y
	STA (BEGAD),Y
	DEY
	BPL MAIN6
MAIN0	JSR BAS_RST
	JSR L_INS
	JMP MAIN

L_INS	LDA BASBEG		;LINE INSERT/DELETE
	LDY BASBEG+1
	STA T_PNT
	STY T_PNT+1
	CLC
L_INS2	LDY #1
	LDA (T_PNT),Y
	BEQ L_INSX
	LDY #4
L_INS1	INY
	LDA (T_PNT),Y
	BNE L_INS1
	INY
	TYA
	ADC T_PNT
	TAX
	LDY #0
	STA (T_PNT),Y
	LDA T_PNT+1
	ADC #0
	INY
	STA (T_PNT),Y
	STX T_PNT
	STA T_PNT+1
	BCC L_INS2
L_INSX	RTS


GETLINE	LDX #0			;GET LINE FROM input device
	LDY IN_DEV
	BEQ GETLIN1
GETLN1	JSR CHRIN
	CMP #LF			;ignore LF's
	BEQ GETLN1
	CMP #CR
	BEQ GETLNX
	STA INBUF,X
	INX
	BNE GETLN1
GETLNX	JMP ST_EOT

GETLIN7	DEX			;do RUBOUT
	BMI GETLIN3
	DEX
	STX P_FORL
	LDA #BS
GL_RUB	INX
	JSR CHROUT
	LDA INBUF+1,X
	STA INBUF,X
	BNE GL_RUB
	LDA #SP			;delete last CHR
	JSR CHROUT
	JMP GLBCUR2

GETLIN1	LDA IO_CHAN		;switch io channel to console
	PHA
	STX IO_CHAN
	STX INBUF
	DB BIT_Z
GETLIN3	INX
GETLIN0	JSR CHRIN		;INPUT CHR VIA BIOS
	CMP #CR			;CR
	BNE GETLIN2
	JSR ST_EOT
	PLA
	STA IO_CHAN		;restore io channel
	RTS

GETLIN2	CMP #RUBOUT		;Delete CHR left from cursor
	BEQ GETLIN7
	CMP #SP
	BCC GETLIN4
GL_INS	STX P_FORL		;CHR insert into line
GL_INS1	LDY INBUF,X
	STA INBUF,X
	JSR CHROUT		;ECHO CHR TO SCREEN
	INX
	TYA
	BNE GL_INS1
	STA INBUF,X
GL_BCUR	DEX			;Move cursor back
GLBCUR1	CPX P_FORL
	BEQ GETLIN3
GLBCUR2	LDA #BS			;do a backspace
	JSR CHROUT
	JMP GL_BCUR

GETLIN4	CMP #BS
	BNE GETLIN5
GETLN4B	LDA #BS
	DEX
	BMI GETLIN3
GETLN4A	JSR CHROUT
	JMP GETLIN0

GETLIN5	CMP #HT
	BNE GETLIN6
GETLN5A	LDA INBUF,X
	BEQ GETLIN0
	INX
	LDA #HT
	BNE GETLN4A

GETLIN6	CMP #SI			;toggle echo
	BNE G_CHR1
	LDA OUT_F
	EOR #$FF
	STA OUT_F
GETLN10	JMP GETLIN0

G_CHR1	CMP #CTRLA		;cursor to begin of line
	BNE GETLIN8
	LDA #$FF
	STA P_FORL
	BNE GL_BCUR

GETLIN8	CMP #CTRLF		;move cursor to EOL
	BNE GETLIN9
	DB BIT_Z
GETLN8A	PHA			;entry from EDIT
GETLN8B	LDA INBUF,X
	BEQ GETLIN0
	JSR CHROUT
	INX
	BNE GETLN8B

GETLIN9	CMP #CTRLS
	BEQ GETLN4B
	CMP #CTRLD
	BEQ GETLN5A	
	BNE GETLN10		;all other chr's suppressed


UCASE	CMP #'a			;upper case conversion
	BCC UCASEX
	CMP #'{
	BCS UCASEX
	AND #$5F
UCASEX	RTS


G_TOKEN	LDX CHRGTP		;GET BASIC TOKEN
	LDY #4
	STY DATA_F
G_TOK1	LDA INBUF,X
	BPL G_TOK2
	INX
	BNE G_TOK1
G_TOK2	CMP #SP
	BEQ G_TOK3
	STA HK_F
	CMP #HK
	BEQ G_TOK4
	BIT DATA_F
	BVS G_TOK3
	CMP #'?
	BNE G_TOK5
	LDA #PRINT_TOK
	BNE G_TOK3
G_TOK5	CMP #'0
	BCC G_TOK6
	CMP #'<
	BCC G_TOK3
G_TOK6	STY P_FUNC
	JSR S_BBEF
	STX CHRGTP
	LDY #0
	STY INBUFP
G_TOK14	LDA INBUF,X
	JSR UCASE		;lower -> upper case
	SEC
	SBC (PNT),Y
	BNE G_TOK7
	INX
	INY
	BNE G_TOK14
G_TOK17	INC PNT+1
	BNE G_TOK14

G_TOK7	CMP #$80		;BASIC COMMAND?
	BNE G_TOK8
	ORA INBUFP
G_TOK15	LDY P_FUNC
G_TOK3	INX
	INY
	JSR UCASE
	STA INBUF-5,Y
	ORA #$00		;END OF LINE?
	BEQ G_TOK9
	SEC
	SBC #':
	BEQ G_TOK10
	CMP #73			;DATA Token?
	BNE G_TOK11
G_TOK10	STA DATA_F
G_TOK11	SEC
	SBC #85
	BNE G_TOK1
	STA HK_F
G_TOK12	LDA INBUF,X
	BEQ G_TOK3
	CMP HK_F
	BEQ G_TOK3
G_TOK4	INY
	STA INBUF-5,Y
	INX
	BNE G_TOK12
G_TOK8	LDX CHRGTP
	INC INBUFP
G_TOK13	LDA (PNT),Y
	BMI G_TOK16
	INY
	BNE G_TOK13
	INC PNT+1
	BNE G_TOK13

G_TOK16	INY
	BEQ G_TOK17
	LDA (PNT),Y
	BNE G_TOK14
	LDA INBUF,X
	BPL G_TOK15
G_TOK9	STA INBUF-3,Y
	DEC CHRGTP+1
	LDA #INBUF-1
	STA CHRGTP
	RTS


S_BBEF	LDY #BAS_BEF		;set PNT = BAS_BEF
	STY PNT
	LDY #BAS_BEF/256
	STY PNT+1
	RTS


G_LINNR	LDA BASBEG		;GET BASIC LINE NR
	LDX BASBEG+1
G_LINN4	LDY #1
	STA BEGAD
	STX BEGAD+1
	LDA (BEGAD),Y
	BEQ G_LINN1
	INY
	INY
	LDA BASADR+1
	CMP (BEGAD),Y
	BCC G_LINNX
	BEQ G_LINN2
	DEY
	BNE G_LINN3
G_LINN2	LDA BASADR
	DEY
	CMP (BEGAD),Y
	BCC G_LINNX
	BEQ G_LINNX
G_LINN3	DEY
	LDA (BEGAD),Y
	TAX
	DEY
	LDA (BEGAD),Y
	BCS G_LINN4
G_LINN1	CLC
G_LINNX	RTS


NEW	BNE G_LINNX		;NEW COMMAND
COLD	LDA #0
	TAY
	STA (BASBEG),Y
	INY
	STA (BASBEG),Y
	LDA BASBEG
	CLC
	ADC #2
	STA VTBEG
	LDA BASBEG+1
	ADC #0
	STA VTBEG+1
BAS_RST JSR SET_CGP		;SET CHR GET POINTER
	LDA #0

CLR	BNE CLRX		;CLR COMMAND
CLR1	LDA NXTAD
	LDY NXTAD+1
	STA STREND
	STY STREND+1
	JSR RES_IO
	LDA VTBEG
	LDY VTBEG+1
	STA ATBEG
	STY ATBEG+1
	STA VTEND
	STY VTEND+1
	JSR RESTORE
RESET	LDX #STRTAB
	STX DES_PNT
	PLA
	TAY
	PLA
	LDX #$FA
	TXS
	PHA
	TYA
	PHA
	LDA #0
	STA NXTBEF+1
	STA DIM_F
CLRX	RTS


SET_CGP	CLC			;SET CHR POINTER ON START
	LDA BASBEG
	ADC #$FF
	STA CHRGTP
	LDA BASBEG+1
	ADC #$FF
	STA CHRGTP+1
SET_CGX	RTS


LIST	BCC LIST1		;LIST COMMAND
	BEQ LIST1
	CMP #$AB		;- TOKEN
	BNE SET_CGX
LIST1	JSR G_FIX
	JSR G_LINNR
	JSR GETCHR1
	BEQ LIST2
	CMP #$AB		;- TOKEN
	BNE SET_CGX
	JSR GETCHR
	JSR G_FIX
	BNE SET_CGX
LIST2	PLA
	PLA
	LDA BASADR
	ORA BASADR+1
	BNE LIST3
	LDA #$FF
	STA BASADR
	STA BASADR+1
LIST3	LDY #1
	STY DATA_F
	LDA (BEGAD),Y
	BEQ LIST4
	JSR BRKTST
	JSR CRLF
	INY
	LDA (BEGAD),Y
	TAX
	INY
	LDA (BEGAD),Y
	CMP BASADR+1
	BNE LIST5
	CPX BASADR
	BEQ LIST6
LIST5	BCS LIST4
LIST6	STY P_FORL
	JSR PRT_16
	LDA #SP
LIST13	LDY P_FORL
	AND #$7F
LIST9	JSR PRT_CHR
	CMP #'"
	BNE LIST7
	LDA DATA_F
	EOR #$FF
	STA DATA_F
LIST7	INY
	BEQ LIST4
	LDA (BEGAD),Y
	BNE LIST8
	TAY
	LDA (BEGAD),Y
	TAX
	INY
	LDA (BEGAD),Y
	STX BEGAD
	STA BEGAD+1
	BNE LIST3
LIST4	JMP WARM

LIST8	BPL LIST9
	BIT DATA_F
	BMI LIST9
	JSR F_BBEF		;find basic command
LIST10	LDA (PNT),Y
	BMI LIST13
	JSR PRT_CHR
	INY
	BNE LIST10
	INC PNT+1
	BNE LIST10


EDIT	BEQ EDIT1		;EDIT COMMAND
	JSR G_FIX		;get line nr from command line
EDIT1	JSR G_LINNR		;search line
	LDY #2
	LDA (BEGAD),Y		;GET LINE NR
	STA F_ACCU1+2
	INY
	LDA (BEGAD),Y
	STA F_ACCU1+1
	STY P_FORL		;SAVE Y
	LDX #$90
	SEC
	JSR INTFLT		;CONVERT INT TO FLT
	JSR FLT_ASC		;CONVERT FLT TO ASCII
	LDX #0			;X is INBUF pointer
EDIT2	LDA STACK,X		;COPY ASCII NR TO INPUT BUFFER
	BEQ EDIT7
	STA INBUF,X
	INX
	BPL EDIT2

EDIT7	LDA #SP			;SPACE
EDIT3	LDY P_FORL
	AND #$7F
EDIT5	STA INBUF,X
	INX
	INY
	BEQ LIST4
	LDA (BEGAD),Y		;GET NEXT CHR
	BEQ EDIT4		;IF NOT EOL
	BPL EDIT5		;AND NOT A TOKEN
	STX P_FORL+1
	JSR F_BBEF		;FIND BASIC COMMAND
	LDX P_FORL+1
EDIT6	LDA (PNT),Y
	BMI EDIT3
	STA INBUF,X
	INX
	INY
	BNE EDIT6
	INC PNT+1
	BNE EDIT6

EDIT4	STA INBUF,X		;STORE 0 TO END OF STRING
	JSR RES_IO
	TAX			;X=0!
	JSR GETLN8A
	JMP MAIN7


F_BBEF	STY P_FORL		;find basic command
	JSR S_BBEF
	LDY #0
	AND #$7F
	TAX
	BEQ FBBEFX
FBBEF2	LDA (PNT),Y
	BPL FBBEF1
	DEX
	BEQ FBBEF3
FBBEF1	INY
	BNE FBBEF2
	INC PNT+1
	BNE FBBEF2

FBBEF3	INY
	BNE FBBEFX
	INC PNT+1
FBBEFX	RTS


FOR	LDA #$80		;FOR COMMAND
	STA DIM_F
	JSR LET
	JSR S_FORL
	BNE FOR1
	TXA
	ADC #$0F
	TAX
	TXS
FOR1	PLA
	PLA
	LDA #9
	JSR STK_CHK
	JSR S_NXTC
	CLC
	TYA
	ADC CHRGTP
	PHA
	LDA CHRGTP+1
	ADC #0
	PHA
	LDA ALINNR+1
	PHA
	LDA ALINNR
	PHA
	LDA #$A4		;CHECK FOR 'TO' TOKEN?
	JSR CHK_CHR
	JSR CHK_NUM
	JSR ANALYZE
	LDA F_ACCU1+5
	ORA #$7F
	AND F_ACCU1+1
	STA F_ACCU1+1
	LDA #FOR2
	LDY #FOR2/256
	STA T_PNT
	STY T_PNT+1
	JMP DOIT2

FOR2	LDA #F_CONST
	LDY #F_CONST/256
	JSR FIL_A1
	JSR GETCHR1
	CMP #$A9			;CHECK FOR 'STEP' TOKEN
	BNE FOR3
	JSR GETCHR
	JSR ANALYZE
FOR3	JSR CHK_A1S
	JSR DOIT1
	LDA P_FORL+1
	PHA
	LDA P_FORL
	PHA
	LDA #$81
	PHA

EX_NXTC	JSR BRKTST		;EXECUTE NEXT BASIC COMMAND
	LDA CHRGTP
	LDY CHRGTP+1
	CPY #INBUF/256		;Direct mode?
	BEQ EXNXTC1
	STA NXTBEF
	STY NXTBEF+1
EXNXTC1	LDY #0
	LDA (CHRGTP),Y
	BNE EXEC8
	LDY #2
	LDA (CHRGTP),Y
	CLC
	BNE EXNXTC2
	JMP BREAK4

EXNXTC2	INY
	LDA (CHRGTP),Y
	STA ALINNR
	INY
	LDA (CHRGTP),Y
	STA ALINNR+1
	TYA
	ADC CHRGTP
	STA CHRGTP
	BCC EXEC
	INC CHRGTP+1
EXEC	JSR GETCHR		;EXECUTE BASIC COMMAND
	JSR EXE
	JMP EX_NXTC


EXE	BEQ RESTORX		;EXEC BASIC COMMAND AS SUBROUTINE
EXEC1	SBC #$80
	BCC EXEC2
	CMP #35			;max. 35 BASIC COMMANDS as RTS-JUMP
	BCS EXEC3
EXEC5	ASL A
	TAY
	LDA COM_TAB+1,Y
	PHA
	LDA COM_TAB,Y
	PHA
	JMP GETCHR

EXEC2	JMP LET

EXEC8	CMP #':
	BEQ EXEC
EXEC4	JMP SYN_ERR

EXEC3	CMP #90			;new functions
	BCC EXEC4
	CMP #92
	BCS EXEC4
	SBC #16			;adjust pointer
	BCS EXEC5


RESTORE	SEC			;RESTORE COMMAND
	LDA BASBEG
	SBC #1
	LDY BASBEG+1
	BCS RESTOR1
	DEY
RESTOR1	STA NXTDATA
	STY NXTDATA+1
RESTORX	RTS


STOP	BCS STOP1		;STOP COMMAND
END	CLC			;EXECUTE ALSO END AND BREAK
STOP1	BNE CONTX
	LDA CHRGTP
	LDY CHRGTP+1
	LDX ALINNR+1
	INX
	BEQ STOP2
	STA NXTBEF
	STY NXTBEF+1
STOP4	LDA ALINNR
	LDY ALINNR+1
	STA CONTLN
	STY CONTLN+1
STOP2	PLA
	PLA
BREAK4	LDA #BREAKM
	LDY #BREAKM/256
	LDX #0
	STX OUT_F		;OUTPUT ENABLE
	BCC STOP3
	JMP ERROR3		;BREAK IN ...

STOP3	JMP WARM		;'READY'


CONT	BNE CONTX		;CONT COMMAND
	LDX #ERR16-ERR_TAB
	LDY NXTBEF+1
	BNE CONT1
	JMP ERROR
CONT1	LDA NXTBEF
	STA CHRGTP
	STY CHRGTP+1
	LDA CONTLN
	LDY CONTLN+1
	STA ALINNR
	STY ALINNR+1
CONTX	RTS


RUN	BNE GOSUB0		;RUN COMMAND
	JMP BAS_RST


GOSUB0	JSR CLR1
	JMP GOSUB1

GOSUB	LDA #3			;GOSUB COMMAND
	JSR STK_CHK
	LDA CHRGTP+1
	PHA
	LDA CHRGTP
	PHA
	LDA ALINNR+1
	PHA
	LDA ALINNR
	PHA
	LDA #$8D		;GOSUB TOKEN
	PHA
GOSUB1	JSR GETCHR1
	JSR GOTO
	JMP EX_NXTC


GOTO	JSR G_FIX		;GOTO COMMAND
	JSR S_NXTL
	LDA ALINNR+1
	CMP BASADR+1
	BCS GOTO1
	TYA
	SEC
	ADC CHRGTP
	LDX CHRGTP+1
	BCC GOTO2
	INX
	BCS GOTO2
GOTO1	LDA BASBEG
	LDX BASBEG+1
GOTO2	JSR G_LINN4
	BCC UDF_ERR
	LDA BEGAD
	SBC #1
	STA CHRGTP
	LDA BEGAD+1
	SBC #0
	STA CHRGTP+1
GOTO3	RTS


RETURN	BNE GOTO3		;RETURN COMMAND
	LDA #$FF
	STA P_FORL+1
	JSR S_FORL
	TXS
	CMP #$8D		;GOSUB TOKEN
	BEQ DATA0
	LDX #ERR2-ERR_TAB	;RETURN WITHOUT GOSUB
	DB BIT_ABS
UDF_ERR	LDX #ERR7-ERR_TAB	;UNDEF'D STAEMENT
	JMP ERROR

RETURN1	JMP SYN_ERR		;SYNTAX ERROR


DATA0	PLA
	PLA
	STA ALINNR
	PLA
	STA ALINNR+1
	PLA
	STA CHRGTP
	PLA
	STA CHRGTP+1
DATA	JSR S_NXTC		;DATA COMMAND
DATA1	TYA
	CLC
	ADC CHRGTP
	STA CHRGTP
	BCC DATAX
	INC CHRGTP+1
DATAX	RTS


S_NXTC	LDX #':			;SEARCH NEXT COMMAND
	DB BIT_ABS
S_NXTL	LDX #0			;SEARCH NEXT LINE
	STX SRC_CHR
	LDY #0
	STY HK_F
S_NXT1	LDA HK_F
	LDX SRC_CHR
	STA SRC_CHR
	STX HK_F
S_NXT2	LDA (CHRGTP),Y
	BEQ DATAX
	CMP HK_F
	BEQ DATAX
S_NXT3	INY
	CMP #'"
	BNE S_NXT2
	BEQ S_NXT1


IF	JSR IN_TERM		;IF COMMAND
	JSR GETCHR1
	CMP #$89		;GOTO TOKEN
	BEQ IF1
	LDA #$A7		;THEN TOKEN
	JSR CHK_CHR
IF1	LDA F_ACCU1
	BNE REM1


REM	JSR S_NXTL		;REM COMMAND
	BEQ DATA1
REM1	JSR GETCHR1
	BCS REM2
	JMP GOTO
REM2	JMP EXE


ON	JSR TRMCALC		;ON COMMAND
	PHA
	CMP #$8D		;GOSUB TOKEN
	BEQ ON1
ON4	CMP #$89		;GOTO TOKEN
	BNE RETURN1		;SYNTAX ERROR
ON1	DEC F_ACCU1+4
	BNE ON2
	PLA
	JMP EXEC1

ON2	JSR GETCHR
	JSR G_FIX
	CMP #',
	BEQ ON1
	PLA
ON3	RTS


G_FIX	LDX #0			;GET FIXED DIGIT NR
	STX BASADR
	STX BASADR+1
G_FIX1	BCS ON3
	SBC #'0'-1		;C=0 !
	STA SRC_CHR		;ASCII TO HEX CONVERSION
	LDA BASADR+1
	STA T_PNT
	CMP #$19
	BCS ON4
	LDA BASADR
	ASL A
	ROL T_PNT
	ASL A
	ROL T_PNT
	ADC BASADR
	STA BASADR
	LDA T_PNT
	ADC BASADR+1
	STA BASADR+1
	ASL BASADR
	ROL BASADR+1
	LDA BASADR
	ADC SRC_CHR
	STA BASADR
	BCC G_FIX2
	INC BASADR+1
G_FIX2	JSR GETCHR
	JMP G_FIX1


LET	JSR S_VAR		;LET COMMAND
	STA P_FORL
	STY P_FORL+1
	LDA #$B2		;TOKEN FOR '=
	JSR CHK_CHR
	LDA INT_F
	PHA
	LDA VAR_F
	PHA
	JSR IN_TERM
	PLA
	ROL A
	JSR CHK_NUX
	BNE LET2
	PLA
LET1	BPL LET3
	JSR A1RND		;ROUND ACCU 1
	JSR F_INT1		;CONVERT TO INT
	LDY #0
	LDA F_ACCU1+3
	STA (P_FORL),Y
	INY
	LDA F_ACCU1+4
	STA (P_FORL),Y
	RTS

LET3	JMP A1_FOR

LET2	PLA
LET4	LDY P_FORL+1
	CPY #CON_TAB+2/256	;if TI$ !!!
	BNE LETA
	JSR GARCOL1
	CMP #$6
	BNE ASC_IN1
	LDY #0
	STY F_ACCU1
	STY F_ACCU1+5
LET6	STY P_FUNC
	JSR ASC_IN
	JSR A1MUL10		;ACCU1 * 10
	INC P_FUNC
	LDY P_FUNC
	JSR ASC_IN
	JSR A1_A2		;COPY ACCU1 TO ACCU2
	TAX
	BEQ LET5
	INX
	TXA
	JSR A1MUL1A
LET5	LDY P_FUNC
	INY
	CPY #6
	BNE LET6
	JSR A1MUL10
	JSR FN_INT
	LDX #2
	SEI
LET7	LDA F_ACCU1+2,X
	STA CLOCK,X
	DEX
	BPL LET7
	CLI
	RTS


ASC_IN	LDA (T_PNT),Y		;READ ASCII NR IN ACCU 1
	JSR GETCHR2
	BCC ASC_IN2
ASC_IN1	JMP ILLQ_ERR		;ILLEGAL QUANTITY ERROR
ASC_IN2	SBC #$2F
	JMP RD_ASCNR

LETA	LDY #2
	LDA (F_ACCU1+3),Y
	CMP STREND+1
	BCC LETA1
	BNE LETA2
	DEY
	LDA (F_ACCU1+3),Y
	CMP STREND
	BCC LETA1
LETA2	LDY F_ACCU1+4
	CPY VTBEG+1
	BCC LETA1
	BNE LETA3
	LDA F_ACCU1+3
	CMP VTBEG
	BCS LETA3
LETA1	LDA F_ACCU1+3
	LDY F_ACCU1+4
	JMP LETA4
LETA3	LDY #0
	LDA (F_ACCU1+3),Y
	JSR G_STRP		;GET STRING POINTER
	LDA GCMEM
	LDY GCMEM+1
	STA ACOMP
	STY ACOMP+1
	JSR STR_MEM
	LDA #$5E
	LDY #0
LETA4	STA GCMEM
	STY GCMEM+1
	JSR FIX_DT		;FIX DESCRIPTOR TABLE
	LDY #0
	LDA (GCMEM),Y
	STA (P_FORL),Y
	INY
	LDA (GCMEM),Y
	STA (P_FORL),Y
	INY
	LDA (GCMEM),Y
	STA (P_FORL),Y
	RTS


PRINT@	JSR CMD			;PRINT# COMMAND
	JMP RES_IO


CMD	JSR TRMCALC		;CMD COMMAND
	BEQ CMD1
	JSR CHK_KM
CMD1	PHP
	JSR SET_OUT
	STX IO_CHAN		;set IO channel
	PLP
	JMP PRINT


PRINT1	JSR PRT_STR1		;PRINT COMMAND
PRINT0	JSR GETCHR1
PRINT	BEQ CRLF
PRINT2	BEQ PRINTX
	CMP #$A3		;TAB()
	BEQ TAB
	CMP #$A6		;SPC()
	CLC
	BEQ TAB
	CMP #',
	BEQ PRINT4
	CMP #';
	BEQ TAB3		;REPEAT PRINT
	JSR IN_TERM
	BIT VAR_F
	BMI PRINT1		;IF VARTYP = STRING
	JSR FLT_ASC		;CONVERT FLOAT TO ASCII
	JSR S_STR		;SEARCH STRING ELEMENT
	JSR PRT_STR1		;PRINT AND REMOVE IT
	JSR PRT			;PRINT CHARACTER '> OR ' '
	BNE PRINT0
ST_EOT	LDA #0			;SAVE $00 AS EOT
	STA INBUF,X
	LDX #INBUF-1
	LDY #INBUF-1/256
	LDA IO_CHAN
	BNE PRINTX		;IF IO-CHANNEL <> 0 THEN RTS
CRLF	LDA #CR
	JSR PRT_CHR
	LDA #LF
	JSR PRT_CHR
	EOR #$FF
PRINTX	RTS

PRINT4	LDA CUR_COL
	SEC
PRINT8	SBC #10
	BCS PRINT8
	EOR #$FF
	ADC #1
	BNE TAB1
TAB	PHP
	JSR TRMCAL0
	CMP #')
	BNE PRT_ERR
	PLP
	BCC TAB2
	TXA
	SBC CUR_COL
	BCC TAB3
TAB1	TAX
TAB2	INX
TAB4	DEX
	BNE TAB5
TAB3	JSR GETCHR
	JMP PRINT2

TAB5	JSR PRT
	BNE TAB4

PRT_STR	JSR S_STR		;PRINT STRING IN A/Y
PRT_STR1 JSR GARCOL1
	TAX
	LDY #0
	INX
PRT_ST2	DEX
	BEQ PRINTX		;EOT!
	LDA (T_PNT),Y
	JSR PRT_CHR
	INY
	BNE PRT_ST2


PRT	LDA IO_CHAN		;PRINT 1 CHR
	BEQ PRT_SP
	LDA #SP
	DB BIT_ABS
PRT_SP	LDA #HT
	DB BIT_ABS
PRT_3F	LDA #'?
PRT_CHR	BIT OUT_F
	BMI PRT1
	PHA
	JSR CHROUT
	PLA
PRT1	AND #$FF		;RESET N AND Z FLAGS
	RTS


INP_ERR	LDA INP_F		;HANDLE INPUT ERRORS
	BEQ INP_ER1
	BMI INP_ER2
	LDY #$FF
	BNE INP_ER3
INP_ER2	LDA ADATA
	LDA ADATA+1
INP_ER3	STA ALINNR
	STY ALINNR+1
PRT_ERR	JMP SYN_ERR		;SYNTAX ERROR
INP_ER1	LDA IO_CHAN
	BEQ INP_ER4
	LDX #ERR14-ERR_TAB	;FILE DATA ERROR
 	JMP ERROR

INP_ER4	LDA #REDOM
	LDY #REDOM/256
	JSR PRT_STR
	LDA NXTBEF
	LDY NXTBEF+1
	STA CHRGTP
	STY CHRGTP+1
	RTS


GET	JSR DIR_TST		;GET COMMAND
	CMP #'#			;TEST FOR DIRECT MODE
	BNE GET1
	JSR GETCHR
	JSR GETARG
GET1	LDX #INBUF+1
	LDY #INBUF+1/256
	LDA #0
	STA INBUF+1
	LDA #$40		;INPUT FLAG
	JSR READ1
	LDX IO_CHAN
	BNE INP@1
	RTS


GETARG	JSR TRMCALC		;GET ARGUMENT
	JSR CHK_KM		;CHECK FOR KOMMA
	JSR SET_IN		;SET INPUT DEVICE
	STX IO_CHAN
	RTS


INPUT@	JSR GETARG		;INPUT# COMMAND
	JSR INPUT1
INP@1	JMP RES_IO


INPUT	LSR OUT_F		;INPUT COMMAND
	CMP #'"
	BNE INPUT1
	JSR CHK_ST1
	LDA #';
	JSR CHK_CHR
	JSR PRT_STR1
INPUT1	JSR DIR_TST		;TEST FOR DIRECT MODE
	LDA #',
	STA STACK+$FF
INPUT3	JSR INP_EX
	LDA IO_CHAN
	BEQ INPUT2
	LDA STATUS
	AND #$40		;EOF reached?
	BEQ INPUT2
	JSR RES_IO
	JMP DATA

INPUT2	LDA INBUF
	BNE READ2
	LDA IO_CHAN
	BNE INPUT3
	CLC
	JMP STOP4

INP_EX	LDA IO_CHAN
	BNE INP_EX1
	JSR PRT_3F
	JSR PRT
INP_EX1	JMP GETLINE


READ	LDX NXTDATA		;READ COMMAND
	LDY NXTDATA+1
	LDA #$98
	DB BIT_ABS
READ2	LDA #00
READ1	STA INP_F
	STX INPPNT
	STY INPPNT+1
READ3	JSR S_VAR
	STA P_FORL
	STY P_FORL+1
	LDA CHRGTP
	LDY CHRGTP+1
	STA AOPER
	STY AOPER+1
	LDX INPPNT
	LDY INPPNT+1
	STX CHRGTP
	STY CHRGTP+1
	JSR GETCHR1
	BNE READ4
	BIT INP_F
	BVC READ5
	JSR CHRIN
	STA INBUF
	LDX #INBUF-1
	LDY #INBUF-1/256
	BNE READ6

READ5	BMI READ10
	LDA IO_CHAN
	BNE READ7
	JSR PRT_3F
READ7	JSR INP_EX
READ6	STX CHRGTP
	STY CHRGTP+1
READ4	JSR GETCHR
	BIT VAR_F
	BPL READ20
	BIT INP_F
	BVC READ8
	INX
	STX CHRGTP
	LDA #0
	STA SRC_CHR
	BEQ READ9
READ8	STA SRC_CHR
	CMP #'"
	BEQ READ11
	LDA #':
	STA SRC_CHR
	LDA #',
READ9	CLC
READ11	STA HK_F
	LDA CHRGTP
	LDY CHRGTP+1
	ADC #0
	BCC READ12
	INY
READ12	JSR S_STR1
	JSR VAL8
	JSR LET4
	JMP READ21

READ20	JSR STR_VAL
	LDA INT_F
	JSR LET1
READ21	JSR GETCHR1
	BEQ READ22
	CMP #',
	BEQ READ22
	JMP INP_ERR
READ22	LDA CHRGTP
	LDY CHRGTP+1
	STA INPPNT
	STY INPPNT+1
	LDA AOPER
	LDY AOPER+1
	STA CHRGTP
	STY CHRGTP+1
	JSR GETCHR1
	BEQ READ23
	JSR CHK_KM
	JMP READ3

READ10	JSR S_NXTC
	INY
	TAX
	BNE READ24
	LDX #'*
	INY
	LDA (CHRGTP),Y
	BEQ NEXT2
	INY
	LDA (CHRGTP),Y
	STA ADATA
	INY
	LDA (CHRGTP),Y
	INY
	STA ADATA+1
READ24	LDA (CHRGTP),Y
	TAX
	JSR DATA1
	CPX #$83
	BNE READ10
	JMP READ4

READ23	LDA INPPNT
	LDY INPPNT+1
	LDX INP_F
	BPL READ25
	JMP RESTOR1

READ25	LDY #0
	LDA (INPPNT),Y
	BEQ READX
	LDA IO_CHAN
	BNE READX
	LDA #EXTRAM
	LDY #EXTRAM/256
	JMP PRT_STR

READX	RTS


NEXT	BNE NEXT1		;NEXT COMMAND
	LDY #0
	BEQ NEXT3
NEXT1	JSR S_VAR
NEXT3	STA P_FORL
	STY P_FORL+1
	JSR S_FORL
	BEQ NEXT4
	LDX #ERR_TAB-ERR_TAB
NEXT2	BEQ TM_ERR1		;NEXT WITHOUT FOR ERROR
NEXT4	TXS
	TXA
	CLC
	ADC #4
	PHA
	ADC #6
	STA PNT
	PLA
	LDY #1
	JSR FIL_A1
	TSX
	LDA STACK+9,X
	STA F_ACCU1+5
	LDA P_FORL
	LDY P_FORL+1
	JSR V_PA1
	JSR A1_FOR
	LDY #1
	JSR COMPA11
	TSX
	SEC
	SBC STACK+9,X
	BEQ CHK_DF
	LDA STACK+$F,X
	STA ALINNR
	LDA STACK+$10,X
	STA ALINNR+1
	LDA STACK+$12,X
	STA CHRGTP
	LDA STACK+$11,X
	STA CHRGTP+1
NEXT5	JMP EX_NXTC


CHK_DF	TXA			;CHECK DATA FORMAT
	ADC #$11
	TAX
	TXS
	JSR GETCHR1
	CMP #',
	BNE NEXT5
	JSR GETCHR
	JSR NEXT1


ANALYZE	JSR IN_TERM		;ANALYZE TERM
CHK_NUM	CLC
	DB BIT_Z
CHK_NU1	SEC
CHK_NUX	BIT VAR_F
	BMI CHK_NU2
	BCS TM_ERR
CHK_NU3	RTS
CHK_NU2	BCS CHK_NU3

TM_ERR	LDX #ERR12-ERR_TAB	;TYPE MISMATCH ERROR
TM_ERR1	JMP ERROR


IN_TERM	LDX CHRGTP		;INPUT AND ANALYZE TERM
	BNE IN_TER1
	DEC CHRGTP+1
IN_TER1	DEC CHRGTP
	LDX #0
	DB BIT_Z
IN_TER2	PHA
	TXA
	PHA
	LDA #1
	JSR STK_CHK		;STACK CHECK
	JSR ANA_ARG		;ANALYSE ARGUMENT
	LDA #0
	STA OPMSK
IN_TER3	JSR GETCHR1
IN_TER4	SEC
	SBC #$B1
	BCC IN_TER5		;CHECK FOR < = >
	CMP #3
	BCS IN_TER5
	CMP #1
	ROL A
	EOR #$01
	EOR OPMSK
	CMP OPMSK
	BCC J_SYNER
	STA OPMSK
	JSR GETCHR
	JMP IN_TER4

IN_TER5	LDX OPMSK
	BNE IN_TER6
	BCS P_ARG8
	ADC #7
	BCC P_ARG8
	ADC VAR_F
	BNE IN_TER7
	JMP CONCAT		;DO STRING CONCATENATION

IN_TER7	ADC #$FF
	STA T_PNT
	ASL A
	ADC T_PNT
	TAY
IN_TERB	PLA
	CMP OP_TAB,Y
IN_TER8	BCS P_ARG9
	JSR CHK_NUM
IN_TERC	PHA
IN_TERD	JSR P_ARG
	PLA
	LDY AOPER
	BPL IN_TER9
	TAX
	BEQ P_ARG10
	BNE P_ARG11

IN_TER6	LSR VAR_F
	TXA
	ROL A
	LDX CHRGTP
	BNE IN_TERA
	DEC CHRGTP+1
IN_TERA	DEC CHRGTP
	LDY #$1B
	STA OPMSK
	BNE IN_TERB
IN_TER9	CMP OP_TAB,Y
	BCS P_ARG11
	BCC IN_TERC


P_ARG	LDA OP_TAB+2,Y		;PUSH ARGUMENT ON STACK
	PHA
	LDA OP_TAB+1,Y
	PHA
	JSR DOIT
	LDA OPMSK
	JMP IN_TER2

J_SYNER	JMP SYN_ERR


DOIT	LDA F_ACCU1+5
	LDX OP_TAB,Y
DOIT1	TAY
	PLA
	STA T_PNT
	INC T_PNT
	PLA
	STA T_PNT+1
	TYA
	PHA
DOIT2	JSR A1RND
	LDA F_ACCU1+4
	PHA
	LDA F_ACCU1+3
	PHA
	LDA F_ACCU1+2
	PHA
	LDA F_ACCU1+1
	PHA
	LDA F_ACCU1
	PHA
	JMP (T_PNT)

P_ARG8	LDY #$FF
	PLA
P_ARG10	BEQ P_ARG1
P_ARG9	CMP #$64
	BEQ P_ARG2
	JSR CHK_NUM
P_ARG2	STY AOPER
P_ARG11	PLA
	LSR A
	STA SGN_F
	PLA
	STA F_ACCU2
	PLA
	STA F_ACCU2+1
	PLA
	STA F_ACCU2+2
	PLA
	STA F_ACCU2+3
	PLA
	STA F_ACCU2+4
	PLA
	STA F_ACCU2+5
	EOR F_ACCU1+5
	STA F_ACCU2+6
P_ARG1	LDA F_ACCU1
	RTS


ANA_ARG	LDA #0			;ANALYZE ARGUMENTS
	STA VAR_F
ANAARG3	JSR GETCHR
	BCS ANAARG1
ANAARG2	JMP STR_VAL
ANAARG1	JSR CHK_LET		;CHECK FOR LETTER
	BCS S_BVAR
CHK_ST	CMP #'.			;CHECK STATEMENT FOR +-."
	BEQ ANAARG2
	CMP #'+'+$80
	BEQ CHK_STE
	CMP #'*'+$80
	BEQ ANAARG3
	CMP #'"
	BNE CHK_ST3
CHK_ST1	LDA CHRGTP
	LDY CHRGTP+1
	ADC #0
	BCC CHK_ST2
	INY
CHK_ST2	JSR S_STR
	JMP VAL8

CHK_ST3	CMP #'('+$80
	BNE CHK_FN
	LDY #$18
	BNE CHKSTE1


NOT	JSR F_INT1		;NOT COMMAND
	LDA F_ACCU1+4
	EOR #$FF
	TAY
	LDA F_ACCU1+3
	EOR #$FF
	JMP INT_FLT


CHK_FN	CMP #$A5		;CHECK FUNCTION
	BNE CHK_FN1		;FN TOKEN
	JMP FN_ANA

CHK_FN1	CMP #$B4		;SGN TOKEN
	BCC CHK_TRM
	JMP C_FTYP
CHK_TRM JSR CHK_28
	JSR IN_TERM
CHK_29	LDA #')
	DB BIT_ABS
CHK_28	LDA #'(
	DB BIT_ABS
CHK_KM	LDA #',
CHK_CHR	LDY #0
	CMP (CHRGTP),Y
	BNE SYN_ERR
	JMP GETCHR

SYN_ERR	LDX #ERR1-ERR_TAB	;SYNTAX ERROR
	JMP ERROR


CHK_STE	LDY #$15		;CHECK STATEMENT FOR ERRORS
CHKSTE1	PLA
	PLA
	JMP IN_TERD


S_BVAR	JSR S_VAR		;SEARCH BASIC VARIABLE
	STA F_ACCU1+3		;VAR NAME POINTER = CHRGTP
	STY F_ACCU1+4		;VAR NAME = VNAME
	LDA VNAME		;VAR ADR = VPNT
	LDY VNAME+1
	LDX VAR_F
	BEQ SBVAR1
	LDX #0
	STX ARND
	BIT F_ACCU1+4
	BMI SBVARX		;If VAR ADR in system area
	CMP #'T			;CHECK FOR TI, TI$ AND ST
	BNE SBVARX
	CPY #'I'+$80
	BNE SBVARX
	JSR SBVAR2
	STY BUF2+2
	DEY
	STY P_FUNC
	LDY #6
	STY BUF2+1
	LDY #$24
	JSR FLTASCA
	JMP STR@1

SBVARX	RTS

SBVAR1	LDX INT_F
	BPL SBVAR3
	LDY #0
	LDA (F_ACCU1+3),Y
	TAX
	INY
	LDA (F_ACCU1+3),Y
	TAY
	TXA
	JMP INT_FLT

SBVAR3	BIT F_ACCU1+4
	BMI SBVAR4		;if VAR ADR in system area
	CMP #'T
	BNE SBVAR5
	CPY #'I
	BNE SBVAR4
	JSR SBVAR2
	TYA
	LDX #$A0
	JMP INT_F1

SBVAR2	LDA #CLOCK-2
	LDY #CLOCK-2/256
	SEI
	JSR FIL_A1
	CLI
	STY F_ACCU1+1
	RTS

SBVAR5	CMP #'S
	BNE SBVAR4
	CPY #'T
	BNE SBVAR4
	LDA STATUS
	JMP BYT_FLT

SBVAR4	CMP #'P
	BNE SBVAR6
	CPY #'I
	BNE SBVAR6
	LDA #PI
	LDY #PI/256
	JMP FIL_A1		;FILL ACCU 1 WITH PI

SBVAR6	LDA F_ACCU1+3
	LDY F_ACCU1+4
	JMP FIL_A1


C_FTYP	ASL A			;CHECK FUNCTION TYPE
	PHA
	TAX
	JSR GETCHR
	CPX #$8F		;REM?
	BCC C_FTYP1
	JSR CHK_28
	JSR IN_TERM
	JSR CHK_KM
	JSR CHK_NU1
	PLA
	TAX
	LDA F_ACCU1+4
	PHA
	LDA F_ACCU1+3
	PHA
	TXA
	PHA
	JSR TRMCALC
	PLA
	TAY
	TXA
	PHA
	JMP C_FTYP2

C_FTYP1	JSR CHK_TRM
	PLA
	TAY
C_FTYP2	LDA COM_TAB-$22,Y
	STA J_FN+1
	LDA COM_TAB-$21,Y
	STA J_FN+2
	JSR J_FN		;JUMP TO BASIC FUNCTION
	JMP CHK_NUM


OR	LDY #$FF		;OR COMMAND
	DB BIT_ABS
AND	LDY #0			;AND COMMAND
	STY INBUFP
	JSR F_INT1
	LDA F_ACCU1+3
	EOR INBUFP
	STA SRC_CHR
	LDA F_ACCU1+4
	EOR INBUFP
	STA SRC_CHR+1
	JSR A2_A1
	JSR F_INT1
	LDA F_ACCU1+4
	EOR INBUFP
	AND SRC_CHR+1
	EOR INBUFP
	TAY
	LDA F_ACCU1+3
	EOR INBUFP
	AND SRC_CHR
	EOR INBUFP
	JMP INT_FLT


COMP	JSR CHK_NUX			;COMPARE
	BCS COMP1
	LDA F_ACCU2+5
	ORA #$7F
	AND F_ACCU2+1
	STA F_ACCU2+1
	LDA #F_ACCU2
	LDY #F_ACCU2/256
	JSR COMP_A1
	TAX
	JMP COMP2

COMP1	LDA #0
	STA VAR_F
	DEC OPMSK
	JSR GARCOL1
	STA F_ACCU1
	STX F_ACCU1+1
	STY F_ACCU1+2
	LDA F_ACCU2+3
	LDY F_ACCU2+4
	JSR GARCOL2
	STX F_ACCU2+3
	STY F_ACCU2+4
	TAX
	SEC
	SBC F_ACCU1
	BEQ COMP3
	LDA #1
	BCC COMP3
	LDX F_ACCU1
	LDA #$FF
COMP3	STA F_ACCU1+5
	LDY #$FF
	INX
COMP6	INY
	DEX
	BNE COMP4
	LDX F_ACCU1+5
COMP2	BMI COMP5
	CLC
	BCC COMP5
COMP4	LDA (F_ACCU2+3),Y
	CMP (F_ACCU1+1),Y
	BEQ COMP6
	LDX #$FF
	BCS COMP5
	LDX #1
COMP5	INX
	TXA
	ROL A
	AND SGN_F
	BEQ COMP7
	LDA #$FF
COMP7	JMP BYT_FLT


DIM0	JSR CHK_KM		;DIM COMMAND
DIM	TAX
	JSR S_VAR1
	JSR GETCHR1
	BNE DIM0
	RTS


S_VAR	LDX #0			;SEARCH VARABLE
	JSR GETCHR1
S_VAR1	STX DIMBUF
S_VAR2	STA VNAME
	JSR GETCHR1
	JSR CHK_LET
	BCS S_VAR3
S_VERR	JMP SYN_ERR

S_VAR3	LDX #0
	STX VAR_F
	STX INT_F
	JSR GETCHR
	BCC S_VAR4
	JSR CHK_LET
	BCC S_VAR5
S_VAR4	TAX
S_VAR6	JSR GETCHR
	BCC S_VAR6
	JSR CHK_LET
	BCS S_VAR6
S_VAR5	CMP #'$
	BNE S_VAR7
	LDA #$FF
	STA VAR_F
	BNE S_VAR8

S_VAR7	CMP #'%
	BNE S_VAR9
	LDA DIM_F
	BNE S_VERR
	LDA #$80
	STA INP_F
	ORA VNAME
	STA VNAME
S_VAR8	TXA
	ORA #$80
	TAX
	JSR GETCHR
S_VAR9	STX VNAME+1
	SEC
	ORA DIM_F
	SBC #'(
	BNE S_VAR10
	JMP S_FLD

S_VAR10	LDA #0
	STA DIM_F
	LDA VTBEG
	LDX VTBEG+1
	LDY #0
S_VAR14	STX BEGAD+1
S_VAR13	STA BEGAD
	CPX ATBEG+1
	BNE S_VAR11
	CMP ATBEG
	BEQ M_VAR
S_VAR11	LDA VNAME
	CMP (BEGAD),Y
	BNE S_VAR12
	LDA VNAME+1
	INY
	CMP (BEGAD),Y
	BEQ P_VARP
	DEY
S_VAR12	CLC
	LDA BEGAD
	ADC #7
	BCC S_VAR13
	INX
	BNE S_VAR14


CHK_LET	CMP #'A			;CHECK FOR A LETTER
	BCC CHKLETX
	SBC #'[
	SEC
	SBC #$A5
CHKLETX	RTS


M_VAR	PLA			;MAKE ROOM FOR VARABLE
	PHA
	CMP #S_BVAR+2		
	BNE MVAR1
MVAR3	LDA #CON_TAB+2		;CON_TAB+2 ???
	LDY #CON_TAB+2/256
	RTS

MVAR1	LDA VNAME
	LDY VNAME+1
	CMP #'T
	BNE MVAR2
	CPY #'I'+$80
	BEQ MVAR3
	CPY #'I
	BNE MVAR2
MVAR5	JMP SYN_ERR
MVAR2	CMP #'S
	BNE MVAR4
	CPY #'T
	BEQ MVAR5
MVAR4	LDA ATBEG
	LDY ATBEG+1
	STA BEGAD
	STY BEGAD+1
	LDA VTEND
	LDY VTEND+1
	STA ENDAD
	STY ENDAD+1
	CLC
	ADC #7
	BCC MVAR6
	INY
MVAR6	STA TARGAD
	STY TARGAD+1
	JSR M_ROOM
	LDA TARGAD
	LDY TARGAD+1
	INY
	STA ATBEG
	STY ATBEG+1
	LDY #0
	LDA VNAME
	STA (BEGAD),Y
	INY
	LDA VNAME+1
	STA (BEGAD),Y

RESVAR	LDA #0			;RESET VARIABLE=0
RESVAR1	INY
	STA (BEGAD),Y
	CPY #6
	BCC RESVAR1

P_VARP	LDA BEGAD		;PUSH VAR POINTER TO VPNT
	CLC
	ADC #2
	LDY BEGAD+1
	BCC PVARP1
	INY
PVARP1	STA VPNT
	STY VPNT+1
	RTS


S_FLDH	LDA INBUFP		;SEARCH IN A FIELD HELP ROUTINE
	ASL A
	ADC #5
	ADC BEGAD
	LDY BEGAD+1
	BCC SFLDH1
	INY
SFLDH1	STA TARGAD
	STY TARGAD+1
	RTS


NR_INT	JSR GETCHR		;GET BASIC NR AND CONVERT TO INT
	JSR IN_TERM
NR_INT1	JSR CHK_NUM

F_INT	LDA F_ACCU1+5		;FLT TO 16 BIT INTEGER
	BMI F_INT2
F_INT1	LDA F_ACCU1
	CMP #$90
	BCC F_INT3
	LDA #M32768
	LDY #M32768/256
	JSR COMP_A1
F_INT2	BNE ILLQ_ERR
F_INT3	JMP FN_INT
	

S_FLD	LDA DIMBUF		;SEARCH FIELD
	ORA INT_F
	PHA
	LDA VAR_F
	PHA
	LDY #0
S_FLD1	TYA
	PHA
	LDA VNAME+1
	PHA
	LDA VNAME
	PHA
	JSR NR_INT
	PLA
	STA VNAME
	PLA
	STA VNAME+1
	PLA
	TAY
	TSX
	LDA STACK+2,X
	PHA
	LDA STACK+1,X
	PHA
	LDA F_ACCU1+3
	STA STACK+2,X
	LDA F_ACCU1+4
	STA STACK+1,X
	INY
	JSR GETCHR1
	CMP #',
	BEQ S_FLD1
	STY INBUFP
	JSR CHK_29
	PLA
	STA VAR_F
	PLA
	STA INT_F
	AND #$7F
	STA DIMBUF
	LDA ATBEG+1
	LDX ATBEG
S_FLD5	STA BEGAD+1
	STX BEGAD
	CMP VTEND+1
	BNE S_FLD2
	CPX VTEND
	BEQ S_FLD3
S_FLD2	LDY #0
	LDA (BEGAD),Y
	INY
	CMP VNAME
	BNE S_FLD4
	LDA VNAME+1
	CMP (BEGAD),Y
	BEQ RDA_ERR
S_FLD4	INY
	LDA (BEGAD),Y
	CLC
	ADC BEGAD
	TAX
	INY
	LDA (BEGAD),Y
	ADC BEGAD+1
	BCC S_FLD5
BS_ERR	LDX #ERR8-ERR_TAB	;BAD SUBSCRIPT ERROR
	DB BIT_ABS
ILLQ_ERR LDX #ERR4-ERR_TAB	;ILLEGAL QUANTITY ERROR
A_ERR	JMP ERROR

RDA_ERR	LDX #ERR9-ERR_TAB	;REDIM'D ARRAY ERROR
	LDA DIMBUF
	BNE A_ERR
	JSR S_FLDH
	LDA INBUFP
	LDY #4
	CMP (BEGAD),Y
	BNE BS_ERR
	JMP S_FLD10

S_FLD3	JSR S_FLDH
	JSR GARBCOL
	LDA #0
	TAY
	STA P_FUNC+1
	LDX #5
	LDA VNAME
	STA (BEGAD),Y
	BPL S_FLD6
	DEX
S_FLD6	INY
	LDA VNAME+1
	STA (BEGAD),Y
	BPL S_FLD7
	DEX
	DEX
S_FLD7	STX P_FUNC
	LDA INBUFP
	INY
	INY
	INY
	STA (BEGAD),Y
S_FLD9	LDX #11
	LDA #0
	BIT DIMBUF
	BVC S_FLD8
	PLA
	CLC
	ADC #1
	TAX
	PLA
	ADC #0
S_FLD8	INY
	STA (BEGAD),Y
	INY
	TXA
	STA (BEGAD),Y
	JSR S_FLD20
	STX P_FUNC
	STA P_FUNC+1
	LDY T_PNT
	DEC INBUFP
	BNE S_FLD9
	ADC TARGAD+1
	BCS S_FLD11
	STA TARGAD+1
	TAY
	TXA
	ADC TARGAD
	BCC S_FLD12
	INY
	BEQ S_FLD11
S_FLD12	JSR GARBCOL
	STA VTEND
	STY VTEND+1
	LDA #0
	INC P_FUNC+1
	LDY P_FUNC
	BEQ S_FLD14
S_FLD13	DEY
	STA (TARGAD),Y
	BNE S_FLD13
S_FLD14	DEC TARGAD+1
	DEC P_FUNC+1
	BNE S_FLD13
	INC TARGAD+1
	SEC
	LDA VTEND
	SBC BEGAD
	LDY #2
	STA (BEGAD),Y
	LDA VTEND+1
	SBC BEGAD+1
	INY
	STA (BEGAD),Y
	LDA DIMBUF
	BNE S_FLD19
	INY
S_FLD10	LDA (BEGAD),Y
	STA INBUFP
	LDA #0
	STA P_FUNC
S_FLD21	STA P_FUNC+1
	INY
	PLA
	TAX
	STA F_ACCU1+3
	PLA
	STA F_ACCU1+4
	CMP (BEGAD),Y
	BCC S_FLD15
	BNE S_FLD16
	INY
	TXA
	CMP (BEGAD),Y
	BCC S_FLD17
S_FLD16	JMP BS_ERR
S_FLD11	JMP OM_ERR
S_FLD15	INY
S_FLD17	LDA P_FUNC+1
	ORA P_FUNC
	CLC
	BEQ S_FLD18
	JSR S_FLD20
	TXA
	ADC F_ACCU1+3
	TAX
	TYA
	LDY T_PNT
S_FLD18	ADC F_ACCU1+4
	STX P_FUNC
	DEC INBUFP
	BNE S_FLD21
	STA P_FUNC+1
	LDX #5
	LDA VNAME
	BPL S_FLD22
	DEX
S_FLD22	LDA VNAME+1
	BPL S_FLD23
	DEX
	DEX
S_FLD23	STX REG+2
	LDA #0
	JSR S_FLD24
	TXA
	ADC TARGAD
	STA VPNT
	TYA
	ADC TARGAD+1
	STA VPNT+1
	TAY
	LDA VPNT
S_FLD19	RTS

S_FLD20	STY T_PNT
	LDA (BEGAD),Y
	STA REG+2
	DEY
	LDA (BEGAD),Y
S_FLD24	STA REG+3
	LDA #$10
	STA BUF2+1
	LDX #0
	LDY #0
S_FLD26	TXA
	ASL A
	TAX
	TYA
	ROL A
	TAY
	BCS S_FLD11
	ASL P_FUNC
	ROL P_FUNC+1
	BCC S_FLD25
	CLC
	TXA
	ADC REG+2
	TAX
	TYA
	ADC REG+3
	TAY
	BCS S_FLD11
S_FLD25	DEC BUF2+1
	BNE S_FLD26
	RTS


FRE	LDA VAR_F		;FRE COMMAND
	BEQ FRE1
	JSR GARCOL1
FRE1	JSR RM_STR
	SEC
	LDA STREND
	SBC VTEND
	TAY
	LDA STREND+1
	SBC VTEND+1


INT_FLT	LDX #0			;CONVERT INT TO FLOAT
	STX VAR_F
	STA F_ACCU1+1
	STY F_ACCU1+2
	LDX #$90
	JMP BYTFLT1


POS	LDY CUR_COL		;POS COMMAND
POS1	LDA #0
	BEQ INT_FLT


DIR_TST	LDX DIRECT_F		;TEST FOR DIRECT MODE
	INX
	BNE S_FLD19		;RTS
	LDX #ERR11-ERR_TAB	;ILLEGAL DIRECT ERROR
	DB BIT_ABS
UDFERR	LDX #ERR17-ERR_TAB	;UNDEFINED FUNCTION ERROR
	JMP ERROR


DEF	JSR FN_SYN		;DEFINE FUNCTION COMMAND
	JSR DIR_TST
	JSR CHK_28
	LDA #$80
	STA DIM_F
	JSR S_VAR
	JSR CHK_NUM
	JSR CHK_29
	LDA #$B2		;=
	JSR CHK_CHR
	PHA
	LDA VPNT+1
	PHA
	LDA VPNT
	PHA
	LDA CHRGTP+1
	PHA
	LDA CHRGTP
	PHA
	JSR DATA
	JMP FNANA10


FN_SYN	LDA #$A5		;CHECK FOR FN SYNTAX
	JSR CHK_CHR
	ORA #$80
	STA DIM_F
	JSR S_VAR2
	STA DEFPNT
	STY DEFPNT+1
	JMP CHK_NUM


FN_ANA	JSR FN_SYN		;ANALYZE FN
	LDA DEFPNT+1
	PHA
	LDA DEFPNT
	PHA
	JSR CHK_TRM
	JSR CHK_NUM
	PLA
	STA DEFPNT
	PLA
	STA DEFPNT+1
	LDY #2
	LDA (DEFPNT),Y
	STA VPNT
	TAX
	INY
	LDA (DEFPNT),Y
	BEQ UDFERR
	STA VPNT+1
	INY
FNANA1	LDA (VPNT),Y
	PHA
	DEY
	BPL FNANA1
	LDY VPNT+1
	JSR A1_FOR1
	LDA CHRGTP+1
	PHA
	LDA CHRGTP
	PHA
	LDA (DEFPNT),Y
	STA CHRGTP
	INY
	LDA (DEFPNT),Y
	STA CHRGTP+1
	LDA VPNT+1
	PHA
	LDA VPNT
	PHA
	JSR ANALYZE
	PLA
	STA DEFPNT
	PLA
	STA DEFPNT+1
	JSR GETCHR1
	BEQ FNANA2
	JMP SYN_ERR

FNANA2	PLA
	STA CHRGTP
	PLA
	STA CHRGTP+1
FNANA10	LDY #0
FNANA3	PLA
	STA (DEFPNT),Y
	INY
	CPY #5
	BCC FNANA3
	RTS


STR@	JSR CHK_NUM		;STR$ COMMAND
	LDY #0
	JSR FLTASC1
	PLA
	PLA
STR@1	LDA #$FF
	LDY #0
	BEQ S_STR


G_STRP	LDX F_ACCU1+3		;GET STRING POINTER
	LDY F_ACCU1+4
	STX GCMEM
	STY GCMEM+1
GSTRP1	JSR G_CHRP
	STX F_ACCU1+1
	STY F_ACCU1+2
	STA F_ACCU1
	RTS


S_STR	LDX #'"			;SEARCH STRING
	STX SRC_CHR
	STX HK_F
S_STR1	STA ACOMP
	STY ACOMP+1
	STA F_ACCU1+1
	STY F_ACCU1+2
	LDY #$FF
S_STR3	INY
	LDA (ACOMP),Y
	BEQ S_STR2
	CMP SRC_CHR
	BEQ S_STR4
	CMP HK_F
	BNE S_STR3
S_STR4	CMP #'"
	BEQ S_STR5
S_STR2	CLC
S_STR5	STY F_ACCU1
	TYA
	ADC ACOMP
	STA P_FUNC
	LDX ACOMP+1
	BCC S_STR6
	INX
S_STR6	STX P_FUNC+1
	LDA ACOMP+1
	BEQ S_STR7
	CMP #2
	BNE S_STR10
S_STR7	TYA
	JSR G_STRP
	LDX ACOMP
	LDY ACOMP+1
	JSR P_STR
S_STR10	LDX DES_PNT
	CPX #$1F
	BNE S_STR8
	LDX #ERR15-ERR_TAB	;FORMULA TOO COMPLEX
S_STR9	JMP ERROR

S_STR8	LDA F_ACCU1
	STA ZERO,X
	LDA F_ACCU1+1
	STA ZERO+1,X
	LDA F_ACCU1+2
	STA ZERO+2,X
	LDY #0
	STX F_ACCU1+3
	STY F_ACCU1+4
	STY ACOMP+1
	DEY
	STY VAR_F
	STX L_STRP
	INX
	INX
	INX
	STX DES_PNT
	RTS


G_CHRP	LSR DATA_F		;GET CHR CHAIN POINTER
GCHRP4	PHA
	EOR #$FF
	SEC
	ADC STREND
	LDY STREND+1
	BCS GCHRP1
	DEY
GCHRP1	CPY VTEND+1
	BCC GCHRP2
	BNE GCHRP3
	CMP VTEND
	BCC GCHRP2
GCHRP3	STA STREND
	STY STREND+1
	STA STRBEG
	STY STRBEG+1
	TAX
	PLA
	RTS

GCHRP2	LDX #ERR6-ERR_TAB
	STA DATA_F
	BMI S_STR9
	JSR RM_STR
	LDA #$80
	STA DATA_F
	PLA
	BNE GCHRP4


RM_STR	LDX NXTAD		;REMOVE UNUSED STRINGS
	LDA NXTAD+1
RMSTR1	STX STREND
	STA STREND+1
	LDY #0
	STY DEFPNT+1
	STY DEFPNT
	LDA VTEND
	LDX VTEND+1
	STA BEGAD
	STX BEGAD+1
	LDA #STRTAB
	LDX #STRTAB/256
	STA T_PNT
	STX T_PNT+1
RMSTR3	CMP DES_PNT
	BEQ RMSTR2
	JSR SDELS1
	BEQ RMSTR3
RMSTR2	LDA #7
	STA GCMEM+3
	LDA VTBEG
	LDX VTBEG+1
	STA T_PNT
	STX T_PNT+1
RMSTR5	CPX ATBEG+1
	BNE RMSTR4
	CMP ATBEG
	BEQ RMSTR6
RMSTR4	JSR S_DELS
	BEQ RMSTR5
RMSTR6	STA TARGAD
	STX TARGAD+1
	LDA #3
	STA GCMEM+3
RMSTR8	LDA TARGAD
	LDX TARGAD+1
RMSTR11	CPX VTEND+1
	BNE RMSTR7
	CMP VTEND
	BNE RMSTR7
	JMP DEL_STR
RMSTR7	STA T_PNT
	STX T_PNT+1
	LDY #0
	LDA (T_PNT),Y
	TAX
	INY
	LDA (T_PNT),Y
	PHP
	INY
	LDA (T_PNT),Y
	ADC TARGAD
	STA TARGAD
	INY
	LDA (T_PNT),Y
	ADC TARGAD+1
	STA TARGAD+1
	PLP
	BPL RMSTR8
	TXA
	BMI RMSTR8
	INY
	LDA (T_PNT),Y
	LDY #0
	ASL A
	ADC #5
	ADC T_PNT
	STA T_PNT
	BCC RMSTR9
	INC T_PNT+1
RMSTR9	LDX T_PNT+1
RMSTR12	CPX TARGAD+1
	BNE RMSTR10
	CMP TARGAD
	BEQ RMSTR11
RMSTR10	JSR SDELS1
	BEQ RMSTR12


S_DELS	LDA (T_PNT),Y		;SEARCH STRING TO BE DELETED
	BMI SDELS5
	INY
	LDA (T_PNT),Y
	BPL SDELS5
	INY
SDELS1	LDA (T_PNT),Y
	BEQ SDELS5
	INY
	LDA (T_PNT),Y
	TAX
	INY
	LDA (T_PNT),Y
	CMP STREND+1
	BCC SDELS2
	BNE SDELS5
	CPX STREND
	BCS SDELS5
SDELS2	CMP BEGAD+1
	BCC SDELS5
	BNE SDELS3
	CPX BEGAD
	BCC SDELS5
SDELS3	STX BEGAD
	STA BEGAD+1
	LDA T_PNT
	LDX T_PNT+1
	STA DEFPNT
	STX DEFPNT+1
	LDA GCMEM+3
	STA J_FN+1
SDELS5	LDA GCMEM+3
	CLC
	ADC T_PNT
	STA T_PNT
	BCC SDELS4
	INC T_PNT+1
SDELS4	LDX T_PNT+1
	LDY #0
	RTS


DEL_STR	LDA DEFPNT+1		;DELETE STRING
	ORA DEFPNT
	BEQ SDELS4
	LDA J_FN+1
	AND #$04
	LSR A
	TAY
	STA J_FN+1
	LDA (DEFPNT),Y
	ADC BEGAD
	STA ENDAD
	LDA BEGAD+1
	ADC #0
	STA ENDAD+1
	LDA STREND
	LDX STREND+1
	STA TARGAD
	STX TARGAD+1
	JSR MOVE
	LDY J_FN+1
	INY
	LDA TARGAD
	STA (DEFPNT),Y
	TAX
	INC TARGAD+1
	LDA TARGAD+1
	INY
	STA (DEFPNT),Y
	JMP RMSTR1


CONCAT	LDA F_ACCU1+4		;CONCATENATE STRINGS
	PHA
	LDA F_ACCU1+3
	PHA
	JSR ANA_ARG
	JSR CHK_NU1
	PLA
	STA ACOMP
	PLA
	STA ACOMP+1
	LDY #0
	LDA (ACOMP),Y
	CLC
	ADC (F_ACCU1+3),Y
	BCC CONCAT1
	LDX #ERR13-ERR_TAB
	JMP ERROR

CONCAT1	JSR G_STRP
	JSR STR_MEM
	LDA GCMEM
	LDY GCMEM+1
	JSR GARCOL2
	JSR P_STR1
	LDA ACOMP
	LDY ACOMP+1
	JSR GARCOL2
	JSR S_STR10
	JMP IN_TER3


STR_MEM	LDY #0			;GET STRING TO MEMORY
	LDA (ACOMP),Y
	PHA
	INY
	LDA (ACOMP),Y
	TAX
	INY
	LDA (ACOMP),Y
	TAY
	PLA
P_STR	STX T_PNT		;PUSH STRING TO MEMORY
	STY T_PNT+1
P_STR1	TAY
	BEQ P_STR2
	PHA
P_STR3	DEY
	LDA (T_PNT),Y
	STA (STRBEG),Y
	TYA
	BNE P_STR3
	PLA
P_STR2	CLC
	ADC STRBEG
	STA STRBEG
	BCC P_STR4
	INC STRBEG+1
P_STR4	RTS


GARCOL	JSR CHK_NU1		;GARBAGE COLLECTION
GARCOL1	LDA F_ACCU1+3
	LDY F_ACCU1+4
GARCOL2	STA T_PNT
	STY T_PNT+1
	JSR FIX_DT
	PHP
	LDY #0
	LDA (T_PNT),Y
	PHA
	INY
	LDA (T_PNT),Y
	TAX
	INY
	LDA (T_PNT),Y
	TAY
	PLA
	PLP
	BNE GARCOL3
	CPY STREND+1
	BNE GARCOL3
	CPX STREND
	BNE GARCOL3
	PHA
	CLC
	ADC STREND
	STA STREND
	BCC GARCOL4
	INC STREND+1
GARCOL4	PLA
GARCOL3	STX T_PNT
	STY T_PNT+1
	RTS


FIX_DT	CPY L_STRP+1		;FIX DESCRIPTOR TABLE
	BNE FIXDTX
	CMP L_STRP
	BNE FIXDTX
	STA DES_PNT
	SBC #3
	STA L_STRP
	LDY #0
FIXDTX	RTS

	APP BASIC1.APP
